%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008

\iffalse

Způsoby, jak reprezentovat a uchovávat \emph{entity} existuje velké množství. V~začátcích herního průmyslu byly \emph{entity} velmi úzce provázány s~okolním kódem, ale díky velikosti týmů, které na hrách pracovaly, a relativní jednoduchosti her toto nebyl problém. Avšak s~růstem složitosti se začaly používat další přístupy, jako například \emph{objektově orientované programování}, kdy je využíván \emph{polymorfismus} a \emph{dědičnost}. 

Cílem této práce je návrh a implementace knihovny pro dynamickou kompozici objektů, za běhu aplikace. Mezi hlavní požadavky patří \emph{thread-safe}\cite{ThreadSafety} rozhraní, které je možné používat ve vícevláknových aplikacích. Další prioritou je skutečné využití a prospěch z~běhu na více vláknech, jednoduchost použití a integrace do již existujících projektů a minimalizace režie.

Práce je rozdělena do čtyř logických celků -- teoretická část\ref{Chap:Theory}, návrh systému\ref{Chap:Design}, implementace\ref{Chap:Implementation}, vyhodnocení a praktická použitelnost výsledné knihovny.

Kapitola \ref{Chap:Theory} se zabývá aktuálním stavem v~návrhu \emph{software} a důvody proč je metoda \emph{datově orientované kompozice} důležitá. Jelikož efektivní využití architektury moderních počítačů je stále více důležité, byly při návrhu knihovny použity techniky datově orientovaného návrhu\cite{DataOrientedDesign}, jehož výhody a bližší popis je součástí kapitoly \ref{Chap:DDD}. Další důležitou částí je efektivní využití vícevláknových procesorů, kterým se zabývá kapitola \ref{Chap:Parallelism}.

Kapitola \ref{Chap:Design} obsahuje obecný návrh systému pro dynamickou kompozici, který není závislý na implementačním jazyce. První část \ref{Chap:Overview} obsahuje přehled celého systému, vymezení funkcionality jednotlivých bloků a jejich komunikace. Následují sekce o~\emph{komponentech}(\ref{Chap:Component}), \emph{systémech}(\ref{Chap:System}) a \emph{entitách}(\ref{Chap:Entity}), ve kterých je specifikována jejich funkce. Návrhem paralelního přístupu a popis podporovaných možností paralelizace se zabývá sekce \ref{Chap:ParallelismDesign}.

Následuje kapitola \ref{Chap:Implementation}, ve které je popsána implementace výše zmíněného návrhu v~jazyce \emph{C++}. První část se zabývá psaním přenositelného kódu v~jazyce \emph{C++} a zdůvodnění výběru implementačního jazyka. Následuje popis implementace jednotlivých částí návrhu. Sekce \ref{Chap:CompImpl} obsahuje způsob registrace \emph{komponentů}, definuje, co může být \emph{komponentem} a základní typy datových struktur pro jejich uchovávání. Následuje popis \emph{systémů}, jejich definice a způsob, jakým jsou určeny k~používání. Dále je zde shrnuta implementace \emph{entity} a výběr mezi horizontálními a vertikálními \emph{metadaty} s~ohledem na paralelizmus. Nakonec je popsána funkce \emph{refresh} a způsoby zajištění parlelního přístupu.

Poslední část se skládá z~příkladu využití knihovny v~kapitole \ref{Chap:Demo} a vyhodnocení \ref{Chap:Eval}. Knihovna je zhodnocena z~pohledu použitelnosti (\ref{Chap:Usability}), výkonosti (\ref{Chap:Performance}) a nakonec porovnána proti vybraným \emph{open-source} knihovnám.

Jelikož se využití \emph{komponentních systémů} začalo objevovat až v~posledních letech, neexistuje obecně uznávaný způsob, jak by přesně měl vypadat. Existuje mnoho různých prací na toto téma

Právě tato metoda -- \emph{kompozice} místo \emph{dědičnosti} -- se začíná v~herním průmyslu používat stále častěji. Díky celkové neprobádanosti tohoto návrhu existuje mnoho různých způsobů jak by takový systém měl vypadat a jaké části by měl obsahovat.

Tato metoda vzniká z~použití tzv. \emph{datově orientovaného návrhu}\cite{DOD}, který se zabývá návrhem aplikací skrz analýzu a transformace dat. Jelikož je tento způsob návrhu stále vcelku nový, existuje mnoho způsobů, jak systém \emph{dynamické kompozice} navrhnout. 

Důležitou vlastností entitního systému založeného na kompozici je právě modularita, která umožňuje ...

Tato metoda vzniká z~použití tzv. \emph{datově orientovaného návrhu}\cite{DOD}.

První dokumentované použití se objevuje ve hře \emph{Dungeon Siege}\cite{DungeonSiege} \emph{Tony Hawk}, kdy \emph{Mick West} během několika let transformoval celou hierarchii na právě kompozici z~\emph{komponentů}. Následoval po

\fi

\chapter{Úvod}

Díky rostoucím požadavkům na moderní hry -- jak ve složitosti herních principů, tak i~věrnosti grafické reprezentace -- se stále zvyšují požadavky na \emph{herní engine}, použitý při jejich tvorbě. Mezi hlavní požadavky patří široké využití v~mnoha herních žánrech, možnosti multiplatformního nasazení, efektivní použití dostupného hardware, ale také jednoduchost a efektivita práce ve velkých týmech. Tyto, ale i další problémy, řeší způsob návrhu pomocí \emph{Entity-component-system} paradigmatu, který v~základu používá princip \emph{kompozice} místo \emph{dědičnosti}.

Jelikož je tato metoda vcelku nová, její širší využití začíná až v~posledních letech. Existuje mnoho návrhů, jak by architektura \emph{entitního systému} založeného na kompozici měla vypadat. Nejčastěji je návrh rozdělen do tří celků -- \emph{entity}, \emph{komponenty} a \emph{systémy}. Výhodou je striktní oddělení logiky od dat a možnost uložení dat do souvislých datových struktur, čímž je dosaženo efektivnější využití výpočetního hardware.

Cílem této bakalářské práce je návrh a implementace \emph{entitního systému} založeného na \emph{datově orientované kompozici}. Hlavními požadavky na tento systém jsou: 
\begin{itemize}
	\item Možnosti paralelního provádění transformací dat.
	\item Efektivní využití hardwarových prostředků.
	\item Jednoduché programovací rozhraní a integrace do existujících projektů.
\end{itemize}
Mezi další požadavky patří efektivní práce s~velkým množstvím \emph{entit}, kde většina z~nich nemusí být aktuálně používána a také efektivní řešení komunikace mezi jednotlivými \emph{komponentami} a \emph{entitami}.

Výsledkem této práce je multiplatformní knihovna pro programovací jazyk \emph{C++}, umožňující vývoj aplikací za použití \emph{Entit-Component-System} paradigmatu. 

Práce je rozdělena do čtyř logických celků -- teoretická část, návrh systému, implementace a vyhodnocení. Kapitola teorie (\ref{Chap:Theory}) popisuje aktuální stav návrhu software, z~pohledu vývoje her a důvody vzniku \emph{ECS} paradigmatu. Nejdříve jsou zde přiblíženy požadavky na \emph{entitní systémy}, následuje porovnání aktuálně používaných způsobů reprezentace \emph{entit} a~srovnání jejich výhod a nevýhod. Závěr se zabývá způsoby, jak využít více-jádrové hardwarové konfigurace. Kapitola návrh (\ref{Chap:Design}) zahrnuje kompletní návrh \emph{entitního systému}, který je obecný -- nezávislý na implementačním jazyce. Úvod obsahuje přehled celého systému, další sekce pokračují podrobnějším popisem jeho částí a rozborem různých způsobů řešení. Následující kapitola -- implementace (\ref{Chap:Implementation}) -- je věnována implementaci výše zmíněného návrhu v~programovacím jazyce \emph{C++}. Závěrečná kapitola (\ref{Chap:Results}) shrnuje vlastnosti výsledného systému z~pohledu výkonosti a srovnává jej s~podobnými volně dostupnými knihovnami.

\chapter{Entitní systémy a jejich využití}
\label{Chap:Theory}

Tato kapitola se věnuje teorii \emph{entitních systémů}, jejich historii a požadavkům na ně kladeným. Dále obsahuje rozbor běžně používaných způsobů reprezentace \emph{entit} a srovnává jejich výhody a nevýhody. Následuje popis vlastního \emph{entitního systému} založeného na \emph{ECS} paradigmatu a definice hlavních pojmů -- \emph{entita}, \emph{komponenta} a \emph{systém}. Na závěr se věnuje metodám paralelizmu, které budou zvažovány pro následující návrh entitního systému.

\section{Entitní systémy}

\emph{Entitní systém} je část herního enginu, který zprostředkovává správu \emph{entit} -- objektů ve virtuálním světě. Alternativní název pro \emph{entitu}, který se také často používá, je \emph{herní objekt} (\emph{Game Object} \cite{UnityGo}). Primární funkcí \emph{entit} je propojení jednotlivých modulů a částí aplikace, které jsou vyvíjeny odděleně -- např. herní logika a simulace fyziky.

\section{Typické problémy entitních systémů}

Stále se zvyšující požadavky na složitost herních principů, věrnost grafické reprezentace a~velikost virtuálních světů mnohonásobně ztěžují návrh \emph{herních enginů}, na kterých jsou hry stavěny. Dalším problémem je znovupoužitelnost již vytvořených částí, nejen ve stejném projektu, ale stále častěji i v~dalších hrách. Z~výše zmíněných důvodů vznikají techniky pro organizaci kódu a knihy \emph{návrhových vzorů} \cite{DesignPatterns, GameDesignPatterns}, které obsahují zkušenosti a prověřené způsoby návrhu software. Důležitou vlastností správného návrhu, je také modularita -- oddělení částí systému -- která umožňuje velkému množství programátorů pracovat na jednom projektu. Základem \emph{Entity-Component-System} paradigmatu je striktní oddělení logiky a~dat, čímž je umožněna vysoká úroveň modularity. 

Způsob reprezentace \emph{entit} -- objektů ve virtuálním světě -- je jedním z~důležitých rozhodnutí v~návrhu \emph{herního enginu}. Entity jsou často používány pro komunikaci mezi jednotlivými podsystémy -- např. přidání efektu z~herní logiky. Přílišná provázanost však většinou znamená zvýšený výskyt programovacích chyb (\emph{bugs}) \cite{GameDesignPatterns}. Podrobněji se tímto zabývá sekce \ref{Chap:Representation}.

\section{Architektura moderních počítačů}

Důležitou součástí tvorby her je analýza cílových platforem, pro které je hra určena. Velkou výhodou je v~dnešní době podobnost všech různých herních systémů. Stolní počítače, ale i některé nové herní konzole (\emph{Playstation 4} a \emph{Xbox One} \cite{Ps4Xbox}), používají architekturu procesorů \emph{x86} \cite{IntelX86-64, AmdX86-64}. Stále důležitější platformou jsou také mobilní zařízení, které většinou používají architekturu procesorů \emph{ARM} \cite{ARM}. Díky podobnosti paměťových hierarchií na těchto platformách je možné implementovat optimalizace, které vylepšují výkon výsledných aplikací na všech cílových systémech.

Moderní procesory dokáží velmi rychle vykonávat jednoduché instrukce a za použití různých mechanizmů (např. \emph{pipelining} \cite{Pipelining}) se stále zvyšuje počet instrukcí zpracovaných za jeden cyklus (\emph{Instructions per Cycle} \cite{CpuIpc}). Problém nastává v~případě, kdy procesor operuje s~daty, které nejsou k~dispozici v~jeho registrech, jelikož rozdíl v~rychlosti procesorů a~přístupové době pamětí stále roste \cite{CpuMemoryGap}. Kvůli těmto rozdílům existuje hierarchie procesorových vyrovnávacích pamětí (\emph{cache}), jejichž cílem je minimalizace rozdílů rychlostí jednotlivých pamětí.

Právě díky rozdílům rychlostí jednotlivých typů pamětí \cite{MemoryTiming} vznikají nové způsoby, jak navrhovat aplikace, které umožňují efektivně využívat hierarchii procesorových vyrovnávacích pamětí. Jedním z~nich je \emph{datově orientovaný} návrh, ze kterého vychází \emph{ECS} paradigma.

Mezi důležité parametry pro efektivní využití \emph{cache} patří lokalita dat \cite{DataLocality} a -- v~případě více-jádrových systémů -- udržování jejich koherence \cite{CacheCoherence}. Lokalita dat je primárně dělena na 2 typy -- časová a prostorová. Časovou lokalitou je myšleno opakované používání stejných dat, kdy se při prvním použití data přesunou do vyrovnávací paměti a~dále je k~nim již přistupováno skrz rychlejší paměť. Načítání dat do \emph{cache} je prováděno v~blocích (\emph{cache line}), jejichž velikost je specifická pro každý procesor. Program, který přistupuje k~datům, jejichž vzdálenost v~paměti není příliš velká (vejdou se do jedné \emph{cache line}) využívá prostorové lokality dat, kdy výsledkem je méně přístupů do pomalejších pamětí. Udržování koherence procesorových \emph{cache} se primárně projevuje ve více-jádrových systémech a podrobněji se jím zabývá sekce \ref{Chap:Parallelism}.

\section{Datově orientovaný návrh}
\label{Chap:DDD}

Dnes nejpoužívanější způsob návrhu -- \emph{objektově orientovaný} (\emph{OOD}) -- umožňuje abstrahovat od fyzického hardware, na kterém výsledná aplikace běží a řešit daný problém jeho dekompozicí do tříd. Základní stavební jednotkou je v~tomto případě třída -- agregace hodnot a  množiny operací nad ní proveditelnou. Toto umožňuje řešení problémů transformací objektů z~reálného světa na objekty virtuální, se kterými dokáží lidé pracovat a zároveň jsou interpretovatelné překladači programovacích jazyků. Toto je však problematické pro moderní výpočetní hardware, který je velmi výkonný v~případě opakovaného provádění jednoduchých datových transformací, ale má problémy s abstrakcí objektu složeného z více částí. Dalším problémem je využití pouze části dat, která daný objekt obsahuje, čímž jsou tato data zbytečně načtena do vyrovnávací paměti a zabírají cennou kapacitu.

Kvůli výše zmíněným problémům vzniká \emph{datově orientovaný návrh}\cite{DOD} (\emph{DOD}), jehož cílem (na rozdíl od \emph{OOD}) je analýza dat, se kterými aplikace pracuje a následovné použití jednoduchých transformací. Nevýhodou využití \emph{OOD} je snížení čitelnosti výsledného kódu a~složitější transformace návrhu aplikace -- který řeší daný problému -- ve výsledný program. Základní myšlenkou je oddělení dat a~operací nad nimi, čímž je umožněno efektivnějšího využití procesorových vyrovnávacích pamětí.

Základem \emph{DOD} je důkladná analýza aplikačních dat -- jejich obor hodnot, transformace, definice vstupních dat, požadovaný výstup atp. Často je využíváno datové struktury typu pole, jejíž vlastnosti umožňují rychlou iteraci. Mezi výhody \emph{DOD} patří také lepší lokalita dat, čímž je zvýšena datová propustnost výsledné aplikace. Díky těmto vlastnostem je \emph{DOD} často využíván při návrhu software, který vyžaduje vysokou úroveň optimalizace -- v~tomto případě při návrhu her\cite{DataOrientedDesignDice, DataOrientedDesignCppCon}.

Častým příkladem rozdílů mezi \emph{OOD} a \emph{DOD} je transformace pole struktur (\emph{AOS}) v~strukturu polí (\emph{SOA}), jejíž ilustraci lze vidět na obr. \ref{Fig:SOAASO}.

\begin{figure}[]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-DOD1}}
	\caption{Příklad transformace pole struktur na strukturu polí.}
	\label{Fig:SOAASO}
\end{figure}

%Entitní systém navržený v této práci vychází z principů \emph{DOD} -- \emph{datově orientovaná kompozice}\cite{DODComponents}. Blíže se tímto způsobem skládání \emph{entit} zabývá sekce \ref{Chap:DOC}.

\section{Reprezentace entit}
\label{Chap:Representation}

Tato sekce obsahuje rozbor nejpoužívanějších způsobů reprezentace \emph{entit} \cite{EvolveHierarchy} a jejich \emph{chování}. Pod pojmem \emph{entita} je myšlen objekt ve virtuálním světě. \emph{Chování}, nebo \emph{aspekt}, definuje operace, které \emph{entita} dokáže provést -- pohyb, vykreslení, kolize atp.

Pro ilustraci návrhu pomocí jednotlivých metod je použit ukázkový návrh jednoduché 2D \uv{shoot'em up} hry, kde prezentovaný návrh není nutně optimální, ale ukazuje vlastnosti dané metody. Dílčí reprezentace entit jsou hodnoceny na základě složitosti implementace, návrhu s~jejich použitím a výhodnosti z~pohledu hardware. Závěry zde vyvozené jsou primárně zaměřené na \emph{třídní} objektově orientované jazyky (\emph{C++}, \emph{JAVA}, \emph{Python} atp.), ale částečně je lze aplikovat i na \emph{objektově orientované} programovací jazyky obecně.

\subsection{Objektově orientovaná hierarchie}

Pod pojmem \emph{objektově orientovaná hierarchie} (\emph{OOH} \cite{GameDesignPatterns}) je míněn způsob skládání nových typů entit za využití \emph{dědičnosti}. Příklad hierarchie, navržené pro ukázkovou 2D hru, lze vidět na obr. \ref{Fig:OOPHierarchy}. V~kořenu stromu hierarchie je, v~případě \emph{OOH}, bázová třída, která umožňuje uniformní skladování entit. Konkrétní entity, které existují v~herním světě, jsou listy ve stromu dědičnosti.

Množina akcí entity je nastřádána průchodem stromu dědičnosti od kořene k~listu, kde se konkrétní entita nachází. Existují dva často používané způsoby definice těchto akcí, kdy u~prvního z~nich je akce specifikována přímo v~supertřídě. Druhým je potom použití \emph{polymorfizmu}, kdy děděné třídy specifikují pouze to, že akce by měla existovat, ale definici nechávají na podtřídě.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.5]{BAC-OOP1}}
	\caption{Příklad objektově orientované hierarchie.}
	\label{Fig:OOPHierarchy}
\end{figure}

Hierarchii dědičnosti, která je v~tomto příkladě použita lze vidět na obr. \ref{Fig:OOPHierarchy}. Bázová třída \textbf{Entity} obsahuje kód pro vykreslování, dále se hierarchie dělí na \emph{entity} pohyblivé a~statické. Prvním problémem je umístění entit, které jsou v~pozadí -- hráč do nich nemůže \uv{narazit}. V~tomto případě je nutné rozdělit nepohyblivé \emph{entity} do dvou podtypů, čímž dochází k~duplikaci kódu ve třídách \textbf{Meteorite} a \textbf{BgMeteorite}. Dalším příkladem problémů s~\emph{OOH} je přidání \uv{nepohyblivé zbraně} -- třídy \textbf{StationaryGun}. Zbraň potřebuje umělou inteligenci, která ji bude ovládat, ale zároveň je také nepohyblivá. Tyto problémy lze u~prezentované hierarchie opravit, ale pro větší projekty to již nemusí být možné. 

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-OOP2}}
	\caption{Příklad obsahu paměti, při využití \emph{objektově orientované hierarchie}.}
	\label{Fig:OOPMemory}
\end{figure}

Pro příklad využití paměti je využit seznam pohybujících se entit, jejichž pozice musí být s každým snímkem hry aktualizována, aplikováním jejich rychlosti. Ilustraci možné organizace paměti lze vidět na obr. \ref{Fig:OOPMemory}. Středem je pole ukazatelů, které obsahuje entity, které je potřeba aktualizovat. Instance jednotlivých konkrétních typů jsou uloženy v~oddělených polích.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-OOP3}}
	\caption{Využití vyrovnávací paměti při použití \emph{objektově orientované} entitní hierarchie. Uvedený příklad pracuje s~objektem \uv{střely}.}
	\label{Fig:OOPCache}
\end{figure}

Při operaci aktualizace je iterováno přes hlavní pole ukazatelů a na každý objekt je aplikována metoda, která aktualizuje jeho pozici přičtením rychlosti. Postup práce s~hlavní pamětí a hierarchií vyrovnávacích pamětí je následující\footnote{Postup neuvažuje různé vrstvy paměti \emph{cache} a předpokládá, že k~požadovanému bloku paměti zatím nebylo přistoupeno. Velikost řádku vyrovnávací paměti je nastavena tak, aby nedošlo k~překrytí paměti ukazatelů a paměti instancí.}. Prvním krokem je načtení bloku paměti, který obsahuje část pole ukazatelů, do vyrovnávací paměti. Následuje dereference prvního z~ukazatelů, která zapříčiní přesun dalšího řádku paměti, který již obsahuje iterované objekty. Ilustrace obsahu paměti \emph{cache} lze vidět na obr. \ref{Fig:OOPCache}. Entity kromě požadovaných informací -- pozice a rychlost -- obsahují také data, která nejsou použita. Výsledkem je neoptimální využití procesorových \emph{cache} \cite{DataOrientedDesignDice}.

Komunikace jednotlivých částí je při použití \emph{OOH} implicitní -- pomocí \emph{public} a \emph{protected} členů. 

\noindent Mezi výhody \emph{OOH} patří: 
\begin{itemize}
	\item Podpora tříd zabudována do mnoha programovacích jazyků.
	\item Použití standardních návrhových metod z~objektově orientovaného návrhu.
	\item Implicitní propojení a komunikace mezi děděnými částmi.
\end{itemize}

\noindent Její nevýhody jsou: 
\begin{itemize}
	\item Akumulace stavu a chování, které není nutně entitou vyžadováno.
	\item Duplikace kódu v~různých větvích stromu dědičnosti.
	\item Zvyšující se složitost umisťování nových typů entit.
	\item Typy entit jsou specifikovány ve zdrojovém kódu.
	\item Statické typování\footnote{Může být výhodou v~některých případech, např. optimalizace, které vykonává překladač.}, nemožnost tvorby nových typů za běhu programu.
\end{itemize}

\subsection{Objektově orientovaná kompozice}

Pod pojmem \emph{objektově orientovaná kompozice} (\emph{OOC} \cite{GameDesignPatterns}) je myšlena tvorba entit z~menších částí -- komponent -- kde komponenty obsahují data a množinu proveditelných akcí. Entita je při použití \emph{OOC} reprezentována jako kontejner, který obaluje seznam komponent (\emph{kompozice}). Příklad návrhu množiny komponent lze vidět na obr. \ref{Fig:OOCHierarchy}, kontejnerem je v~tomto případě třída \textbf{Entity}.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-OOC1_1}}
	\caption{Příklad objektově orientované kompozice.}
	\label{Fig:OOCHierarchy}
\end{figure}

Jelikož komponenty obsahují kromě dat také akce, lze množinu akcí, kterou lze nad výslednou entitou provést, definovat jako sjednocení množin akcí jednotlivých vlastněných komponent. Tato vlastnost umožňuje dynamickou tvorbu entit za běhu aplikace, jejichž chování je definováno přítomnými komponentami.

Tato metoda je často používána\footnote{\uv{Composition over inheritance}} v~návrhu software a je mezikrokem od \emph{objektově orientované hierarchie} k~\emph{datově orientované kompozici}. 

Příkladem využití těchto komponent, pro implementaci stejné množiny konkrétních entit, jako v~případě použití \emph{OOH}, lze vidět na obr. \ref{Fig:OOCEntity}. Oproti využití dědičnosti se zde již lze jednoduše vyhnout problému s~umístěním entit do stromu dědičnosti. Přidání typu \textbf{StationaryGun} je již také bezproblémové, díky možnosti libovolné kombinace jednotlivých komponent.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-OOC1_2}}
	\caption{Využití kompozice pro tvorbu herních objektů. Konkrétní typy entit jsou zde reprezentovány řádky, jednotlivé komponenty jsou potom sloupce. Přítomnost komponenty je vyznačena znakem \uv{\emph{x}}.}
	\label{Fig:OOCEntity}
\end{figure}

Existuje mnoho způsobů, jak tuto základní myšlenku kompozice z~menších částí implementovat. Jednou z~možností je vyhradit pro každý typ komponenty pozici v~seznamu ukazatelů\footnote{Mezi další způsoby patří mapy nebo dynamické seznamy. Možným řešením je také použití obecných ukazatelů a typových proměnných. }. Při použití tohoto návrhu je entita redukována na seznam ukazatelů, kde každá komponenta je buď přítomna (ukazatel je nastavený), nebo nepřítomna (ukazatel je \emph{NULL}). Výhodou této implementace je rychlost, nevýhodou je využití paměti pro větší množství druhů komponent. Ilustraci této implementace lze vidět na obr. \ref{Fig:OOCImpl}. 

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-OOC2}}
	\caption{Obsah paměti u~\emph{objektově orientované kompozice}. Zde je entita implementována pomocí seznamu ukazatelů.}
	\label{Fig:OOCImpl}
\end{figure}

Jako příklad práce s~pamětí je opět použita iterace nad seznamem entit, u~kterých je nutno provést aktualizaci pozice přičtením jejich rychlosti. V~tomto příkladě je použita implementace pomocí statického seznamu ukazatelů, podle obr. \ref{Fig:OOCImpl}.

Podobně, jako při použití \emph{OOH}, je zde iterováno nad polem entit, který však tentokrát obsahuje již jednotlivé instance typu \textbf{Entity}\footnote{Předpokládá se, že všechny entity obsahují komponenty typu \textbf{Position} a \textbf{Velocity}.}. Využití vyrovnávací paměti, za stejných předpokladů, jako v~případě \emph{OOH}, je následující. Nejdříve je načten seznam entit a jejich ukazatelů na jednotlivé komponenty. Požadovaná operace potřebuje pouze ukazatele na komponenty typu \textbf{Position} a \textbf{Velocity}, ostatní jsou v~tomto případě zbytečné. Následuje přístup k~požadovaným komponentám skrz ukazatele v~první entitě. Tímto je načten blok paměti, pro každou komponentu, do vyrovnávací paměti. Po provedení první operace jsou již následující komponenty přístupné z~vyrovnávací paměti. 

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-OOC3}}
	\caption{Využití procesorové \emph{cache} při použití objektově orientované kompozice.}
	\label{Fig:OOCCache}
\end{figure}

Komunikace mezi jednotlivými komponenty je při použití \emph{objektově orientované kompozice} problematické. Jelikož jsou jednotlivé komponenty samostatné objekty, nepřístupné z~ostatních komponent stejné entity, není mezi nimi možná přímá komunikace. Jedním možným řešením je přidání systému zpráv, který má přístup k~celé entitě, včetně jejích komponent. Dílčí komponenty se následně mohou dotazovat na typy zpráv, které je zajímají, nebo je možné využít návrhového vzoru \emph{pozorovatel}. Dalším řešením je umožnit komponentám přímou komunikaci předáním ukazatelů na entitu, nebo na další komponentu, se kterou může daná komponenta komunikovat. Nevýhodou v~případě přímé komunikace je bližší vazba výsledných komponent, což může způsobit chyby při změně některé z~komunikujících stran.

\noindent Mezi výhody \emph{OOC} patří: 
\begin{itemize}
	\item Uniformní instance všech typů entit, liší se pouze v~přítomných komponentách.
	\item Lepší využití vyrovnávacích pamětí.
	\item Možnost definování nových typů entit za běhu, použitím kompozice.
	\item Komponenty, které entita vlastní, jsou přístupny z~jednoho místa.
	\item Odstraněna duplikace kódu a akumulace nechtěného stavu.
\end{itemize}

\noindent Její nevýhody jsou: 
\begin{itemize}
	\item Složitější implementace, většinou bez podpory v~programovacím jazyce.
	\item Komunikace mezi komponentami není implicitní, je nutno ji implementovat. 
\end{itemize}

\pagebreak

\subsection{Datově orientovaná kompozice}
\label{Chap:DOC}

\emph{Datově orientovaná kompozice} (\emph{DOC}) je dalším krokem v~separaci dat a logiky. Podobně, jako \emph{objektově orientovaná kompozice}, \emph{DOC} rozděluje entity do menších části -- komponent -- což umožňuje vyšší modularitu výsledného návrhu. Oproti \emph{OOC} však dochází ke kompletní separaci logiky a~dat, kdy komponenty již neobsahují kód akcí\footnote{Logikou je v~tomto případě myšleno kód, který pracuje na vyšší úrovni, než pouze s~daty dané komponenty. Blíže k~tomuto tématu v~sekci \ref{Chap:EntitySystem}}.

Množinu akcí, které lze nad entitou vykonat, je opět definována přítomnými komponentami. Jelikož komponenty samy o~sobě neobsahují logiku, je nutno akce definovat v~okolním kódu. Jedním způsobem je přímý přístup ke komponentám a jejich datům -- tato metoda bude použita v~následujícím příkladě. Pro rozsáhlejší aplikace, kde je potřeba lepší kontrola nad přístupy k~jednotlivým komponentám, lze například využít \emph{systémy}, které implementují akce nad komponentami\footnote{Tato metoda je blíže popsána v~sekci \ref{Chap:EntitySystem}}. Tento způsob je využit i v~návrhu \emph{entitního systému}, který je výsledkem této práce.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-DOC1_1}}
	\caption{Příklad datově orientované kompozice a návrh komponent, které tvoří výsledné entity.}
	\label{Fig:DOCHierarchy}
\end{figure}

Příklad návrhu entity a komponent lze vidět na obr. \ref{Fig:DOCHierarchy}. Mezi důležité změny, oproti \emph{OOC}, patří veřejný (\emph{public}) přístup k~atributům komponent. Entita je v~tomto návrhu reprezentována číslem -- \emph{identifikátorem} -- skrz který lze komponenty jednoznačně přiřadit k~entitám, které je vlastní. Implementace konkrétních entit je konceptuálně stejná, jako při použití \emph{objektově orientované kompozice}, příklad lze vidět na obr. \ref{Fig:OOCEntity}.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-DOC2}}
	\caption{Obsah paměti u~datově orientované kompozice. \emph{Identifikátor} jednoznačně mapuje entity na jednotlivé instance komponent.}
	\label{Fig:DOCMemory}
\end{figure}

Organizaci paměti, se kterou dále tento příklad pracuje, lze vidět na obr. \ref{Fig:DOCMemory}. Entity jsou uchovávány v~homogenním poli. Jednotlivé identifikátory entit je možné mapovat na komponenty přímou indexací polí komponent.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-DOC3}}
	\caption{Využití procesorové vyrovnávací paměti při použití datově orientované kompozice.}
	\label{Fig:DOCCache}
\end{figure}

Pro ukázku práce s~vyrovnávací pamětí je opět použit příklad iterace nad seznamem entit, které se mají posouvat v~prostoru. Pro vykonání této akce je tedy nutný přístup ke komponentám typu \textbf{Position} a \textbf{Velocity}. Nejdříve je opět přistoupeno k~poli entit, čímž je načten příslušný řádek do vyrovnávací paměti. Jelikož je mapování identifikátorů entit realizováno pomocí přímé indexace\footnote{Za předpokladu, že identifikátory všech iterovaných entit nedovolují díry v~poli komponent.}, je možné po načtení řádku do vyrovnávací paměti pro dané dva typy komponent již následující akce provádět přímo nad pamětí \emph{cache}. Obrázek \ref{Fig:DOCCache} obsahuje ilustraci stavu vyrovnávací paměti, po provedení první operace.

Komunikace mezi jednotlivými částmi je v~případě \emph{datově orientované kompozice} rozdělená do dvou úrovní. První z~nich, komunikace mezi komponentami, je vyřešena implicitně, jelikož akce mohou přistupovat k~několika komponentám. Druhou je potom komunikace mezi zprostředkovateli akcí (např. \emph{systémy}). Tento typ komunikace je možné opět řešit pomocí systému zpráv, nebo událostí. 

\pagebreak

\noindent Mezi výhody \emph{DOC} patří: 
\begin{itemize}
	\item Efektivní skladování entit, které jsou reprezentovány identifikátorem.
	\item Lepší využití vyrovnávacích pamětí.
	\item Možnost definování nových typů entit za běhu, použitím kompozice.
	\item Odstraněna duplikace kódu a akumulace nechtěného stavu.
	\item Možnost efektivní implementace akcí, mimo komponenty.
	\item Opakované provádění jednoduchých akcí, nad seznamy komponent, umožňuje efektivní využití instrukční vyrovnávací paměti.
\end{itemize}

\noindent Její nevýhody jsou: 
\begin{itemize}
	\item Chybí podpora v~programovacích jazycích\footnote{Vzniká programovací jazyk, který bude tento typ kompozice podporovat \cite{OOHLang}.}.
	\item Náročná implementace.
\end{itemize}

\noindent Mezi neutrální vlastnosti patří:
\begin{itemize}
	\item Ztráta abstrakce při práci s~komponentami.
	\item Komponenty jsou čistá data, čímž je umožněna \emph{serializace} entit a komponent.
	\item Akce mohou přistupovat k~několika komponentám.
\end{itemize}

\section{Entity-Component-System}
\label{Chap:EntitySystem} 

Entitní systémy, postavené za použití \emph{datově orientované kompozice} s~využitím \emph{systémů} pro implementaci chování, se nazývají \emph{Entity-Component-System}\footnote{Často používaným označením je také \uv{component base entity system},  \uv{Component-Entity-System}, nebo i \uv{Entity System}.}. Tato část obsahuje popis konceptů, se kterými tento typ entitního systému pracuje a vlastností, které z nich vyplývají.

\subsection{Motivace a koncepty}

\emph{Entity-Component-System} (\emph{ECS} \cite{WhatIsECS, UnderstandingECS}) je návrhové paradigma \cite{EntitySystemsFuture}, založené na kompozici a striktní separaci logiky (\emph{systémy}) a dat (\emph{entity}, \emph{komponenty}). \emph{ECS} vychází z principů \emph{datově orientovaného} návrhu, díky čemuž dokáže efektivně využívat moderní výpočetní hardware. Výsledný systém umožňuje vyšší úroveň modularity a~dynamické změny aplikace za běhu.

Entita je základním stavebním blokem \cite{EntitySystemsFuture}, který lze přirovnat k~objektu z~\emph{objektově orientovaného} návrhu. Na rozdíl od objektů nejsou však entity tvořeny z předem definovaného vzoru (např. třídy), ale jejich funkce -- chování a data -- je definována množinou komponent, které daná entita vlastní. Entity lze reprezentovat pomocí jednoznačných identifikátorů (čísel), které mají podobnou funkci, jako \emph{primární klíče} v~databázi, ilustrace tohoto přirovnání lze vidět na obr. \ref{Fig:ECSDB}.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-ECS1}}
	\caption{Entita reprezentována jako řádek v~databázi. Primárním klíčem je identifikátor entity.}
	\label{Fig:ECSDB}
\end{figure}

Komponenty jsou základními nosiči dat v~\emph{ECS}. Často používaným názvem pro komponenty, je také \uv{aspekt} \cite{EntitySystemsFuture}, jelikož po přiřazení komponent k~entitám mají komponenty další funkci -- určují množinu chování entit. Kromě explicitních dat obsažených v~komponentách existuje také implicitní informace o~tom, zda daná entita obsahuje (má přiřazen) určitý typ komponenty. Každá entita má k~sobě přiřazeno 0 a více\footnote{Častým omezením, které se v reálných implementacích \emph{ECS} objevuje, je omezení maximálního počtu komponent na 1.} komponent daného typu, kde přítomnost komponenty znamená, že entita má definovaný daný aspekt. V~přirovnání \emph{ECS} k~\emph{relační databázi}, lze o~komponentách smýšlet jako o~sloupcích (obr. \ref{Fig:ECSDB}) tabulky entit.

Pokud bychom pokračovali s~přirovnáním k~\emph{OOP} -- entity jsou jednotlivé objekty, komponenty umožňují polymorfizmus -- potom \emph{systémy} implementují chování, nebo metody jednotlivých komponent. Pro mnoho různých typů dat, kde každý typ vyžaduje vlastní chování, je \emph{OOP} výhodné, protože je možné data i operace uložit do jednoho nerozdělitelného celku. Pokud je však nutné vykonat stejnou akci na velkém množství různých typů, \emph{OOP} není optimálním řešením a \emph{ECS} je v~tomto případě vhodnější \cite{EntitySystemsFuture}. 

Každý \emph{systém} provádí danou operaci na všech entitách, které obsahují požadované komponenty (\emph{aspekty}). Základní schéma systému lze vidět na obr. \ref{Fig:ECSSystem}. Výběr vhodných entity je proveden pomocí filtru, který operuje nad přítomností jednotlivých komponent (obr. \ref{Fig:ECSFilter}).

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-ECS3}}
	\caption{Filtr operuje nad entitou a informací o~přítomnosti komponent.}
	\label{Fig:ECSFilter}
\end{figure}

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-ECS2}}
	\caption{Vstupem \emph{systému} jsou entity, ze \emph{systém} kterých vybere pouze ty, které mají odpovídající komponenty. Na vybraných entitách provádí požadované akce.}
	\label{Fig:ECSSystem}
\end{figure}

\subsection{Vlastnosti}

Důvodů, proč se \emph{ECS} používá při návrhu moderních her je mnoho a většina z~nich vzniká díky striktnímu oddělení logiky a dat. Komponenty je možné skladovat v~sekvenčních blocích paměti, čímž je vylepšena efektivita využití vyrovnávacích pamětí. Lokalita dat se vztahuje i na instrukce\footnote{\emph{Instrukční cache} \cite{CpuMemoryGap, InstrAreData}} a díky opakovanému provádění stejných operací nad velkým počtem entit dochází k~vyšší efektivitě využití \emph{instrukční cache}. 

Inherentní modularita \emph{ECS} dovoluje lepší dělení práce ve velkých týmech vývojářů. Každý systém musí předem specifikovat, o~jaké entity (které aspekty musí splňovat) má zájem, tímto je zamezeno nechtěnému ovlivňování okolního kódu. Další výhodou, z~pohledu organizace kódu, je přímočará \emph{refaktorizace} systémů a komponent.

Jelikož komponenty obsahují pouze čistá data bez propojení do externích modulů, je možné přistupovat k~entitnímu systému také z~vestavěného skriptovacího jazyka (např. \emph{LUA}). Skriptovací jazyky bývají hojně využívány jako součást \uv{gameplay}\footnote{Kód, který se stará o~interakce virtuálních objektů ve hře.} funkcí, nebo \emph{umělé inteligence}. Pokročilou vlastností \emph{ECS} může také být přidávání nových typů komponent za běhu aplikace. Tyto, ale i~další (např. \emph{serializace} komponent) funkce, umožňují rychlé prototypování nových herních mechanik.

Při správném rozvržení systémů a jejich požadovaných aspektů, je možné zaručit, že k~ostatním komponentám nebude přistupováno. Tímto je umožněna vyšší úrovně paralelizace celého systému, přestože několik systémů může v~jeden čas přistupovat ke stejné entitě. Paralelizace je dále podporována opakovaným prováděním stejných akcí nad velkým množstvím entit, které lze rozdělit mezi jádra procesoru a~zpracovat je odděleně.

\section{Existující řešení}

Tato část obsahuje porovnání existujících knihoven, které umožňují práci s~entitními systémy založenými na \emph{ECS} paradigmatu. Kromě základního popisu jsou zde také uvedeny výhody a nevýhody daných přístupů. Mezi další známé knihovny pro tvorbu her, které používají komponentní přístup, patří \emph{Unity}, \emph{Unreal Engine}, nebo např. \emph{libGDX} (knihovna \emph{Ashley} \cite{Ashley})

\subsection{EntityX}

\textbf{EntityX} \cite{EntityX} je implementace entitního systému v~programovacím jazyce \emph{C++}, která silně využívá vlastností standardu \emph{C++11} a \emph{šablonového metaprogramování} \cite{CppMetaprogramming}. Toto umožňuje příjemnější práci s~typy, pro uživatele této knihovny. Entity jsou v~tomto případě nepřímo mapovány (pomocí identifikátorů) na komponenty, které jsou uloženy v~souvislých polích, což umožňuje efektivní využití vyrovnávací paměti. 

Kromě základní implementace entitního systému podle \emph{ECS}, knihovna také umožňuje uživatelům knihovny reagovat, když entity \uv{vcházejí}, nebo \uv{vycházejí} do \emph{systémů}, čímž dovoluje entitní systém propojit s~okolním kódem.

Mezi hlavní nevýhody patří delší doba překladu výsledné aplikace -- výsledek použití šablon. Vlastnost, která je na jednu stranu výhodou, ale má i jisté nepříjemné stránky, je nemožnost registrace nových typů komponent za běhu aplikace. Výhodou je v~tomto případě možnost vyšší optimalizace výsledné přeložené aplikace.

\subsection{Artemis}

\textbf{Artemis} \cite{ArtemisJava} je původně knihovna pro programovací jazyk \emph{Java}, ale existuje i mnoho implementací pro další jazyky, např. \emph{C++} (\emph{ArtemisCpp} \cite{ArtemisCpp}). Knihovna využívá \emph{generického programování} jazyka \emph{Java}, čímž opět umožňuje uživateli příjemnější práci. Oproti ostatním knihovnám podporuje vyšší granularitu filtrování entit, kdy je možné specifikovat, které komponenty entita musí, může a nesmí obsahovat. Další zajímavou vlastností je speciální typ komponent -- značky -- které neobsahují žádná data, ale umožňují entity dělit do skupin. 

Knihovna také umožňuje využití pokročilých funkcí, jako sdružování entit a jejich tvorba ve vyšších počtech, nebo entitní \emph{archetypy}, které fungují jako předloha pro další entity.

Knihovna \textbf{Artemis} je ze všech představených knihoven nejvíce dokončená a existují již i projekty, které ji používají.

\subsection{Anax}

Kromě základní implementaci vlastností \emph{ECS}, obsahuje knihovna \textbf{Anax} \cite{Anax} také pojem \emph{skupin}. \emph{Skupiny} obsahují před-generovaný seznam entit, skrz který \emph{systémy} iterují. Výhodou tohoto přístupu je možnost rychlé práce s~celým seznamem entit, které vyhovují určitému filtru. Mezi nevýhody patří nutnost tyto seznamy udržovat. Podobně, jako \textbf{EntityX}, je tato knihovna implementována v~jazyce \emph{C++}. 

\section{Paralelizmus}
\label{Chap:Parallelism}

Vývoj moderních procesorů se ubírá směrem zvyšování počtu výpočetních jader \cite{CPUPerfHistory} a proto i moderní aplikace musí být schopné tato jádra využít. To je zvláště pravda pro vývoj her, které se snaží s~hardware vytěžit maximální výkon. Paralelizace aplikací, jejichž části jsou úzce provázané, je obzvláště problematické a proto vznikají nové způsoby jak tento typ software navrhovat -- jedním z~nich je právě \emph{ECS}. 

Paralelizmus lze obecně rozdělit na 2 typy -- datový a úkolový \cite{KindsOfParallelism}. Při použití datového paralelizmu je prováděna jedna akce na různých datech (obdoba \emph{SIMD} u~procesorů). Opačným přístupem je paralelizmus úkolový \cite{TaskBasedParallelism}, u~kterého mohou běžet různé operace nad stejnými (\emph{MISD}), nebo i různými (\emph{MIMD}) daty. Ve většině případů je však používáno kombinací těchto dvou přístupů. Speciálním případem je vyhrazení celého vlákna jednomu modulu -- např. manažer zvuku -- který vyžaduje nízké odezvy \cite{FrontierThreads}.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-PAR0}}
	\caption{Udržování koherence vyrovnávací paměti a problém falešného sdílení (\uv{false sharing} \cite{FalseSharing}) . Synchronizace \emph{cache} je prováděna mezi jednotlivými jádry, přes specializovanou sběrnici.}
	\label{Fig:PARFalseSharing}
\end{figure}

Výhodou paralelizmu je možnost rozložení práce na několik výpočetních jednotek, což umožňuje požadovanou akci provést rychleji. Využití paralelizmu však představuje mnoho nových typů problémů, které se u~sekvenčního programování nevyskytují. Kromě obecně známých překážek, jako jsou synchronizace vláken, potenciální uváznutí (\emph{deadlock}), různých typů souběhu (\emph{race condition}), existují také problémy na hardwarové úrovni. Hlavním z~nich je udržování koherence procesorových \emph{cache} \cite{CacheCoherence} a skrz to problém, který se nazývá \uv{false sharing} \cite{FalseSharing}. V~případě, že několik vláken pracuje se stejným blokem paměti -- je načtený v~jeho lokální vyrovnávací paměti -- je nutné \emph{cache} jednotlivých jader synchronizovat tak, aby každé z~nich nepracovalo s~jinými daty. Tento proces se nazývá \uv{udržování koherence vyrovnávacích pamětí}. Problém, který v~tomto systému může nastat -- \uv{false sharing} -- vzniká v~případě, kdy obě vlákna pracují nad stejnou pamětí \footnote{Paměť je součástí stejného řádku vyrovnávací paměti.}, ale nepracují se stejnými daty. Při každé změně bude nutno provést synchronizaci, i když není nutná, ilustraci tohoto jevu lze vidět na obr. \ref{Fig:PARFalseSharing}.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-PAR1}}
	\caption{Paralelizmus uvnitř systémů je příkladem datového paralelizmu \cite{KindsOfParallelism}.}
	\label{Fig:PARData}
\end{figure}

\emph{Entity-Component-System} paradigma je výhodné z~pohledu více-jádrových systémů, díky možnosti téměř \cite{AmdahlLaw} dokonalé paralelizace na několika úrovních \cite{ParallelGame}. První úrovní paralelizace, kterou \emph{ECS} umožňuje, je datový paralelizmus, kdy se uvnitř systému množina všech entit, které odpovídají požadavkům, rozdělí na různá jádra, která mohou dané akce provádět odděleně \footnote{Některé typy akcí tento paralelizmus neumožňují - např. výpočet pozic objektů v~grafu scény.}. Ilustrace principu, jak tento způsob pracuje lze vidět na obr. \ref{Fig:PARData}. Dalším způsobem paralelizace je možnost spouštět jednotlivé systémy na oddělených vláknech (obr. \ref{Fig:PARSystem}). Tato metoda je ovšem použitelná pouze pro množinu systémů, kde nemůže nastat situace, kdy několik z~nich přistupuje ke stejným komponentám.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-PAR2}}
	\caption{Paralelizmus na úrovni \emph{systémů}, kdy několik \emph{systémů} pracuje zároveň.}
	\label{Fig:PARSystem}
\end{figure}

Jednoduchý systém může pracovat způsobem transformační funkce, jejíž vstupní parametry jsou komponenty, které systém požaduje a výstupem je zápis (změna) jedné z~těchto komponent. Jelikož je však vhodné -- při paralelním přístupu k~aktuálnímu stavu herního světa -- aby všechny systémy dokázaly přečíst původní data beze změn, lze funkci systémů změnit následujícím způsobem. Systémy mohou místo zápisu nových hodnot do stejných komponent (vstupů) zapsat výsledek do \uv{následujícího stavu} \cite{FrontierThreads}. Při generování nového stavu je nutné určit okamžik, kde se následující stav stane stavem aktuálním, čímž se celý virtuální svět \uv{posune} v čase. Výhodou tohoto přístupu je, že několik vláken může přistupovat (čtení i zápis) ke stejným komponentám.

\chapter{Návrh herního entitního systému}
\label{Chap:Design}

Obsahem této kapitoly je popis návrhu entitního systému založeného na \emph{ECS} paradigmatu. Nejdříve je prezentováno základní rozdělení systému na jednotlivé části a komunikace mezi nimi. Následuje popis návrhu podsystémů -- \emph{komponenty}, \emph{entity} a \emph{systémy}. Každá část obsahuje představení návrhu a jeho zdůvodnění. Následuje návrh paralelního přístupu k~entitnímu systému a jeho tok řízení.

Kromě základních funkcí, které pramení z \emph{ECS} paradigmatu, jsou při návrhu zohledněny také požadavky na umožnění paralelního vykonávání akcí. Navržený systém podporuje paralelizaci na úrovni \emph{entit}, \emph{systému}, ale i formou generování \uv{následujícího stavu}. 

Při návrhu entitního systému byly použity poznatky z~teoretické části této práce a~\emph{open-source} implementace entitních systémů založených na \emph{ECS} paradigmatu -- \emph{EntityX} \cite{EntityX}, \emph{ArtemisCpp} \cite{ArtemisCpp}, \emph{Anax} \cite{Anax}, \emph{Artemis} \cite{ArtemisJava} a \emph{Ashley} \cite{Ashley}.

\section{Přehled a komunikace}

Entitní systém je, podobně jako \emph{ECS} paradigma, rozdělený do několika částí -- modulů -- kde cílem jednotlivých částí je správa některé z~domén \emph{ECS}. Diagram reprezentující toto rozdělení lze vidět na obr. \ref{Fig:DESModules}.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-DES1}}
	\caption{Rozdělení entitního systému do modulů.}
	\label{Fig:DESModules}
\end{figure}

\pagebreak

\noindent Mezi tyto moduly patří:

\begin{itemize}
	\item Modul \textbf{systémů} -- Spravuje registraci \emph{systémů} a jejich vazbu na \emph{skupiny entit}. 
	\item Modul \textbf{skupin} -- Zajišťuje správu \emph{skupin entit}, nad kterými \emph{systémy} iterují, a udržuje jejich konzistenci.
	\item Modul \textbf{komponent} -- Umožňuje registraci \emph{komponent} a správu \emph{nosičů}.
	\item Modul \textbf{entit} -- Spravuje \emph{entity} a udržuje jejich metadata -- přítomnost \emph{komponent}, aktivitu apod.
	\item Modul \textbf{akcí} -- Obsahuje funkcionalitu odložených akcí a generaci \uv{následujícího stavu}.
\end{itemize}

Ovládání celého entitního systému je zastřešeno třídou \textbf{Universe} (obr. \ref{Fig:DESUniverse}), která umožňuje uživateli přístup k~jednotlivým podsystémům. Hlavní funkcí třídy \textbf{Universe} je zprostředkování komunikace mezi moduly -- např. přidání komponenty má dvě části, skutečná operace nad \emph{nosičem komponent} a~úprava metadat (obr. \ref{Fig:DESAddComp} a obr. \ref{Fig:DESAddEnt}). 

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-DES2}}
	\caption{Třída \textbf{Universe} je rozhraním entitního systému.}
	\label{Fig:DESUniverse}
\end{figure}

\section{Komponenty a jejich nosiče}

Komponenty jsou definovány jako základní datové jednotky v~\emph{ECS}, kde každá entita má k~sobě přiřazeno 0-1 komponent daného typu. Komponenty, jak s~nimi pracuje tento návrh, mohou být jakékoliv třídy, kdy jedinou požadovanou informací je typ \emph{nosiče}. \emph{Nosič komponent} je datová struktura, která obsahuje instance \emph{komponent}. Každá komponenta má přiřazen unikátní identifikátor -- \textbf{CompId} -- tento identifikátor je neměnný po dobu běhu entitního systému. Komponenty by měly být pasivní datové struktury\footnote{\emph{Plain old data structure} (\emph{POD}) -- struktura reprezentovaná kolekcí hodnot.}, se kterými lze pracovat jako s~čistou pamětí (přesuny, kopírování, atp.).

O~správu komponent se stará podsystém správy komponent, jehož diagram lze vidět na obr. \ref{Fig:DESCompDiag}. Modul se skládá dvou částí -- registrace typů komponent a \emph{nosiče} komponent. Veškerá komunikace probíhá skrz třídu \textbf{Component Manager}, která obsahuje metody pro registraci komponent a jejich následnou asociaci k~entitám. 

V~první fázi práce s~tímto modulem je třeba registrovat typy komponent, které budou následně používány. Nové komponenty jsou registrovány pomocí metody \textbf{registerComponent}\footnote{Této metodě je třeba předat typ komponenty, která má být registrována, čehož lze docílit pomocí např. \emph{template} (C++), nebo \emph{generics} (Java)}, která vytvoří mapování z~daného typu na jeho registr (\textbf{ComponentRegister}). Kromě identifikátoru, obsahuje registr také \emph{nosič} samotný.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-DES5}}
	\caption{Diagram tříd podsystému správy \emph{komponent}.}
	\label{Fig:DESCompDiag}
\end{figure}

Každý typ komponent je uložen ve vlastním kontejneru -- tzv. nosič komponent. Nosičem je třída, která implementuje všechny požadované operace ze třídy \textbf{BaseComponentHolder} -- přidání, odebrání a získání komponenty specifické entity. Hlavní funkcí nosiče je mapování identifikátorů entit (\textbf{EntityId}) na přiřazené komponenty. 

Různé implementace nosičů, specifické pro určené komponenty, umožňují vyšší úroveň optimalizace pro předpokládané využití komponent. Pokud je např. jisté, že téměř všechny entity budou obsahovat určitý typ komponenty, je možné implementovat nosič jako jednoduché pole, kde mapovací funkcí je prostá indexace komponent pomocí identifikátoru entit. Naopak, pokud je předpokladem, že komponenta bude využívána nízkým počtem entit, nosič může být implementován jako strom, kde klíčem je identifikátor entity. Speciálním typem komponenty je \emph{značka} (\emph{tag}), která neobsahuje žádná data, ale vzniká implicitní informace o~tom, zda má entita danou značku přiřazenu, čehož lze využít pro např. rozdělení entit do skupin.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-DES8}}
	\caption{Sekvenční diagram přidání komponenty, pokračuje na obr. \ref{Fig:DESAddEnt}.}
	\label{Fig:DESAddComp}
\end{figure}

Operace přidání komponenty je rozdělena do dvou částí, první z~nich, která pracuje nad \textbf{ComponentManager} lze vidět na obr. \ref{Fig:DESAddComp}. Po úspěšném přidání komponenty následuje modifikace metadat, kterou se zabývá následující část kapitoly o~návrhu.

\section{Reprezentace entit}

Entita, jako koncept z~\emph{ECS} paradigmatu, je objekt, složený z~paměťově distribuovaných komponent. Pro každou entitu existuje jednoznačné mapování na její komponenty. Vyvstává tedy požadavek na jednoznačný identifikátor entit, který by plnil funkci \emph{primárního klíče} v~tabulce entit (obr. \ref{Fig:ECSDB}).

Pro účely tohoto entitního systému je identifikátor složen ze dvou čísel -- ID a generace. ID je v~tomto případě skutečný \emph{primární klíč} a zároveň plní funkci indexu v tabulce entit. Generační číslo odlišuje různé generace entit, které zabíraly stejný řádek v~tabulce (stejné ID) a je inkrementováno při každém smazání entity. Generační čísla identifikátorů, skrz které je přistupováno k~entitnímu systému jsou porovnány s~aktuální generací dané entity, což umožňuje rozpoznat přístup ke smazaným entitám.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-DES6}}
	\caption{Diagram tříd podsystému správy \emph{entit}.}
	\label{Fig:DESEntityDiagram}
\end{figure}

Podsystém správy entit, jehož diagram tříd lze vidět na obr. \ref{Fig:DESEntityDiagram}, lze přirovnat k~relační databázi. Systém obsahuje jednu tabulku entit, kde každý řádek (\textbf{Metadata}) reprezentuje slot pro entitu. Identifikátor entity je složen z~indexu řádku v~tabulce a jeho generační hodnoty. Každý řádek obsahuje aktuální číslo generace a množinu \emph{bool} hodnot -- metadat. Ilustraci možné konfigurace tabulky metadat lze vidět na obr. \ref{Fig:DESMetadata}. Výhodou této reprezentace je konstantní složitost přístupu k~metadatům dané entity\footnote{Indexace tabulky pomocí \emph{ID} části identifikátoru.}. 

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.9]{BAC-DES11}}
	\caption{Tabulka metadat, indexy jednotlivých entit jsou implicitní indexy řádků.}
	\label{Fig:DESMetadata}
\end{figure}

Jelikož je mapováni identifikátorů entit na komponenty již součástí nosičů komponent, tabulka nemusí tuto informaci obsahovat. Výhodné je však udržování informace o~existenci komponent pro jednotlivé entity, která může být použita pro efektivní filtrování entit. Udržování tohoto typu informace je možné díky jednotnému rozhraní pro práci s~entitním systémem (třída \textbf{Universe}). Mezi typy metadat použité v~tomto návrhu patří: 
\begin{itemize}
	\item Aktivita -- Entita může být ve stavu aktivní, nebo neaktivní.
	\item Obsazenost -- řádek je použitý, nebo prázdný. 
	\item Přítomnosti každého registrovaného typu komponent.
	\item Přítomnost entity ve skupinách \footnote{Více o~skupinách v~části. \ref{Chap:SysGroup} .}.
\end{itemize}

Důležitou součástí \emph{ECS} je možnost pracovat pouze s~entitami, které mají požadované komponenty (\uv{aspekty}). Z~tohoto důvodu obsahuje správa entit i možnost filtrování (třída \textbf{EntityFilter}), které je prováděno pomocí seznamů komponent, jejichž obsah definuje, které komponenty entita musí, nebo nesmí obsahovat. Komponenty, které nejsou obsaženy ani v jednom seznamu jsou při filtrování ignorovány. Filtr obsahuje také další filtrovacím kriterium, které umožňuje specifikovat požadovanou úroveň aktivity entity -- aktivní, nebo neaktivní.

Poslední částí podsystému správy entit je třída \textbf{Entity}, jejíž funkcionalita zjednodušuje práci s~entitním systémem. Operace na ní provedené jsou pouze přesměrovány na třídu \textbf{Universe}, spolu s~příslušným identifikátorem entity. Pomocí této třídy lze také \emph{ECS} propojit s~okolním \emph{objektově orientovaným} kódem.

Nevýhodou udržování informací o~přítomnosti komponent na dvou místech je, že při každé změně je nutné, aby byla provedena i v~metadatech. Příkladem tohoto problému je operace přidání komponenty, jejíž sekvenční diagram lze vidět na obr. \ref{Fig:DESAddComp}. Pokud je první fáze (přidání komponenty z~pohledu \emph{správy komponent}) úspěšná, je nutné upravit metadata.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-DES10}}
	\caption{Sekvenční diagram modifikace metadat při přidání komponenty, pokračování z~obr. \ref{Fig:DESAddComp}.}
	\label{Fig:DESAddEnt}
\end{figure}

\section{Systémy a skupiny}
\label{Chap:SysGroup}

\emph{Systém}, podle \emph{ECS} paradigmatu, obsahuje pravidla pro výběr vhodných entit a akce, které na nich provádí. Entity jsou filtrovány pomocí množiny požadovaných komponent (aspektů). Vstupem \emph{systému} je tedy seznam entit, které vyhovují filtračním pravidlům a jeho cílem je transformovat dané entity a jejich komponenty pomocí definované akce. Tato myšlenka je základem podsystému správy \emph{systémů}. 

Předpokladem, při návrhu tohoto entitního systému je, že i přeš vysoký počet entit, které se v~entitním systému mohou v~jeden okamžik nacházet, bude množství skutečně používaných entit\footnote{Těch, které budou vyhovovat některému ze systémů.} výrazně nižší. Z~tohoto předpokladu vychází myšlenka \emph{skupin}, které plní funkci vyrovnávací paměti \emph{systémů}. \emph{Skupina} je množinou entit, které splňují požadavky specifikované filtrem. Oproti původnímu návrhu, kdy každý \emph{systém} iteruje (lineárně prochází) nad seznamem všech existujících entit v~entitním systému, se při použití skupin již prochází pouze takové entity, které odpovídají požadavkům daného systému.

Jednou z~nevýhod použití \emph{skupin} je nutnost udržovat \emph{skupiny} aktuální, čímž je pověřen podsystém \emph{správy skupin}. Díky potřebě udržování seznamu entitních identifikátorů způsobuje tento systém také vyšší spotřebu paměti. Poslední důležitou vlastností je, že tato funkce předpokládá, že množina všech entit je větší, než množina používaných entit. Pokud tento předpoklad neplatí, potom není vhodné \emph{skupiny} používat.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.6]{BAC-DES3}}
	\caption{Diagramy tříd podsystémů správy \emph{systémů} (vlevo) a správy \emph{skupin} (vpravo).}
	\label{Fig:DESSysGrpDiagram}
\end{figure}

Cílem podsystému správy \emph{systému} (obr. \ref{Fig:DESSysGrpDiagram} vlevo), je údržba systémů a jejich vazba na skupiny. Třída \textbf{SystemManager} umožňuje přidávání a odběr \emph{systémů}. \emph{Systémy} jsou definovány uživatelem, který vytvoří vlastní třídu, jejíž supertřídou je třída \textbf{System}. Dále uživatel musí specifikovat požadované vlastnosti entit -- vyžadované / zakázané komponenty a úroveň aktivity. Následně je možné nový typ \emph{systému} přidat pomocí manažerské třídy.

\emph{Skupiny} (\textbf{EntityGroup}) obsahují 3 seřazené seznamy entitních identifikátorů. Jejich významy jsou následující -- přidané entity, odebrané entity a skutečný seznam všech vyhovujících entit. Primárním důvodem pro existenci prvních dvou je umožnit uživateli propojení entitního systému se zbytkem aplikace\footnote{Např. registrace fyzikálních těles při simulaci \emph{PhysX}.}.

Důležitou vlastností \emph{skupin} je možnost jejich přidávání a odebírání za běhu aplikace\footnote{Některé systémy nemusí zpracovávat entity po celý běh aplikace.}. Toto umožňuje podsystém správy \emph{skupin} (\ref{Fig:DESSysGrpDiagram} vpravo). Každá \emph{skupina} obsahuje \uv{počítadlo referencí}, které reprezentuje na kolika různých místech je \emph{skupina} používána. V~případě, že počítadlo dosáhne hodnoty 0, je \emph{skupina} odstraněna (nebo je zastaven její běh). 
%Správa \emph{skupin} závisí na entitních metadatech, které umožňují efektivnější aktualizace jejich obsahu \footnote{Více o~tomto problému je součástí implementační části \ref{Chap:ImplSystem}.}.

\section{Paralelní přístup}

Díky modulárnímu návrhu entitního systému, který byl předveden, je implementace základních typů paralelního přístupu velmi přímočará. Mezi základní typy paralelizmu, který entitní systém podporuje jsou paralelizmus na úrovni entit a paralelizmus na úrovni systému.

Paralelizmus na úrovni entit využívá \emph{datového paralelizmu}, kde množina entit, nad kterou systém vykonává akce je rozdělena mezi požadovaný počet paralelních vláken, které mohou vykonávat akce odděleně. Tento typ paralelizmu je vhodný pouze v~případech, kdy akce vykonávají transformace na entitách (a jejich komponentách), bez potřeby informací z~ostatních entit. 

Paralelizmus na úrovni systémů lze přirovnat k~\emph{úkolovému paralelizmu}, kde každé vlákno zpracovává rozdílný systém. Tento způsob má opět omezení -- systémy nemohou přistupovat ke stejným komponentám (stejných entit). Tyto dva způsoby paralelizmu lze kombinovat.

V~situacích, kdy není možné použít ani jednu z~těchto možností, nebo při manipulaci globálního kontextu z~několika vláken (např. mazání entit, změna aktivity) je nutné použít jiné řešení. Jedním způsobem, jak tento problém vyřešit, je použití zámků (např. vzájemné vyloučení -- \uv{mutex}), které budou tyto metody chránit před problémy souběhu (\uv{race condition}). Zámky jsou čistým způsobem, jak implementovat bezpečný paralelizmus, ale při vysokém počtu operací zamčení a odemčení je možné ztratit výkon, který byl získán paralelním zpracováním\footnote{Pokud jsou operace chráněné zámky používány často, je možné paralelní aplikaci redukovat na aplikaci sekvenční.}. Kvůli těmto nevýhodám je součástí návrhu také třetí metoda paralelizace -- pomocí \emph{množin změn}.

\emph{Množiny změn} umožňují jednotlivým vláknům odkládat provedení požadovaných operací na pozdější dobu, kdy již bude možné zaručit, že nedojde k~problémům souběhu. Aktuální stav \emph{světa} (entit, komponent apod.) pro každé vlákno je vytvořen překrytím stavu globálního světa danou \emph{množinou změn}. Pokud vlákno použije operaci přidání komponenty, nad danou entitou, skutečné vykonání operace nad globálním kontextem bude odloženo, ale informace o~této operaci bude přidána do \emph{množiny změn} aktuálního vlákna.

\begin{figure}[H]
	\centering
	\tmpframe{\includegraphics[scale=0.5]{BAC-DES7}}
	\caption{Diagram tříd podsystému správy \emph{akcí}.}
	\label{Fig:DESActionDiag}
\end{figure}

Základem podsystému \emph{množin změn}, jehož diagram lze vidět na obr. \ref{Fig:DESActionDiag}, jsou třídy \textbf{ActionCache} a \textbf{ChangeSet}. Úkolem \textbf{ActionCache} je zajistit přístup k~instanci \emph{množin změn}, která bude pro každé vlákno unikátní. Dále umožňuje také potvrzení (\textbf{commitSC}), nebo zrušení (\textbf{resetCS}) \emph{množiny změn} aktuálního vlákna. 

Zajímavým problémem je odložená tvorba entit a jejich následné použití při normálních operacích. Pro operace, které jsou provedeny nad \uv{reálnými} entitami\footnote{Takové entity, které jsou již vytvořeny v~globálním kontextu.} je možno specifikovat cílovou entitu pomocí jejího identifikátoru, čehož není možné dosáhnout u \uv{dočasných} entit, které zatím nemají přiřazený globálně platný identifikátor. Jedním z možných řešení je zakázat provádění operací nad dočasnými entitami, nebo zrušit koncept dočasných entit kompletně a provádět operaci vytvoření entity okamžitě. Druhým řešením, které je součástí tohoto návrhu, je přiřazení speciálního typu identifikátoru \uv{dočasným} entitám, který bude později převeden na identifikátor \uv{reálné} entity.

Dočasné entity jsou reprezentovány třídou \textbf{TemporaryEntity}. Jejich rozhraní je velmi podobné normálním entitám, s tím rozdílem, že dovolují pouze odložené operace. \emph{Množiny změn} samotné jsou reprezentovány třídou \textbf{ChangeSet}, která obsahuje odložené \emph{akce}. \emph{Akce} je možno rozdělit podle typu změn:
\begin{itemize}
	\item Změny metadat -- rušení entit, změna aktivity entit.
	\item Změny komponent -- přidání/odebrání komponent, změna hodnot komponent.
\end{itemize}
\noindent a podle cílové entity: 
\begin{itemize}
	\item Reálné entity -- operace obsahuje identifikátor reálné entity.
	\item Dočasné entity -- operace obsahuje identifikátor dočasné entity.
\end{itemize}

\section{Tok řízení}

Výše navržený entitní systém se vždy nachází v~jedné z~následujících fází -- \emph{inicializace}, \emph{iterace} nebo \emph{obnova}. Diagram řízení toku, který tyto fáze obsahuje, lze vidět na obr. \ref{Fig:DESFlow} vlevo.

\begin{figure}[H]
	\begin{center}
	\tmpframe{\includegraphics[scale=0.6]{BAC-DES9}}
	\end{center}
	\caption{Digram toku řízení entitního systému.}
	\label{Fig:DESFlow}
\end{figure}

Prvním krokem ve fázi inicializace je konstrukce (vytvoření instance) třídy \textbf{Universe}, jejíž součástí je uvedení jednotlivých podsystémů do výchozího stavu. V této fázi je jedinou možnou operací registrace komponent. Tato etapa je završena inicializací entitního systému, kdy je možné vytvoření struktury tabulky entit, jednotlivých nosičů komponent, apod.

Fáze \emph{iterace} umožňuje plný přístup k~entitnímu systému ze strany uživatele. Kromě práce s~entitami a komponentami je také možné přidávat a odebírat \emph{systémy} nebo \emph{skupiny}. Obsah jednotlivých \emph{skupin} je v~této fázi konstantní, čímž je \emph{systémům} umožněno provádění předepsaných akcí. V~okamžiku, kdy již neběží žádné \emph{systémy} je možné přejít do fáze \emph{obnovy}.

Úkolem \emph{obnovovací} fáze je posunutí entitního systému ze stavu \uv{aktuálního} do stavu \uv{následujícího} a dokončení operací, které by vedly k~porušení konzistence. Tohoto cíle je dosaženo postupným voláním operace \textbf{refresh} na jednotlivé podsystémy, jejichž pořadí lze vidět na obr. \ref{Fig:DESFlow} vpravo. Obnova entitního podsystému umožňuje dokončení operací přidání a odebrání \emph{skupin}, u~kterých je nutné měnit počet sloupců v~tabulce metadat. Následuje aplikace \emph{množin změn}, kdy jsou dokončeny odložené operace. Obnova pokračuje volání \textbf{refresh} nad jednotlivými nosiči komponent, kterým je tímto umožněna reorganizace dat. Poslední částí je příprava obsahu \emph{skupin}, čímž je \emph{obnova} dokončena a entitní systém je opět uveden do fáze \emph{iterace}.

\chapter{Implementace}
\label{Chap:Implementation}

Tato kapitola obsahuje popis implementace výše popsaného návrhu entitního systému, založeného na \emph{ECS} paradigmatu. Výsledná implementace obsahuje kompletní jádro, včetně práce s \emph{entitami}, \emph{komponentami} a \emph{systémy}. Kromě těchto základních vlastností umožňuje také všechny tři typy paralelizace -- \emph{entitní}, \emph{systémovou} a pomocí \emph{množin změn} -- přičemž tato kapitola obsahuje pouze zajímavější implementační detaily.

%Výsledkem této implementace je knihovna \uv{Entropy}, která zahrnuje aspekty výše popsaného návrhu.

%V~první části je zdůvodněn výběr implementačního jazyka a použitých knihoven. Následují části zaměřené na jednotlivé podsystémy entitního systému -- \emph{komponenty}, \emph{entity} a \emph{systémy}. Závěr kapitoly je zaměřen na implementaci paralelního přístupu a \emph{obnovovací} fázi. Výsledným produktem této implementace je knihovna, která umožňuje práci s~entitním systémem za využití \emph{ECS} paradigmatu. 

Dosavadní návrh entitního systému lze shrnout do tří částí. První z~nich je správa komponent, kde komponenty jsou základní datové bloky, ze kterých se dále skládají entity. Komponenty jsou uchovávány v~\emph{nosičích} komponent, které zprostředkovávají mapování entit na jejich komponenty. Druhou částí entitního systému jsou entity samotné. Entita je definována identifikátorem, který jednoznačně identifikuje danou entitu. Identifikátor je složen ze dvou částí -- index a generace. Poslední částí jsou \emph{systémy}, které provádějí akce nad entitami. \emph{Systém} je složen z~definice entit, o~které má zájem -- které komponenty entita musí, nebo nesmí obsahovat a požadovanou úroveň aktivity -- a z~akce, kterou nad vybranými entitami provádí. Součástí správy \emph{systémů} jsou také \emph{skupiny}, které operují jako vyrovnávací paměť a obsahují seznam entit pro daný \emph{systém}. 



\section{Implementační nástroje a přenositelnost}

Pro implementaci byl zvolen programovací jazyk \emph{C++} \cite{IsoCpp}, ve standardu \emph{C++14} \cite{Cpp14}. Jazyk \emph{C++} byl vybrán díky dlouhodobému používání v~herním průmyslu v roli primárního implementačního jazyka mnoha herních \emph{enginů}. Mezi jeho další výhody patří optimalizované překladače nebo možnosti výběru z~několika programovacích paradigmat, které podporuje. Jazyk byl použit ve standardu \emph{C++14}, který kromě ulehčení práce s~typy obsahuje také možnosti použití \emph{šablon proměnných} (\emph{variable templates} \cite{Cpp14VarTemplate}). 

Další důležitou vlastností, která byla zvážena při výběru implementačního jazyka, je přenositelnost vytvořené knihovny na různé hardwarové architektury a operační systémy. Díky standardu \emph{C++} je možné psát přenositelný kód, který je následně přeložen na specifické instrukce pro cílovou platformu, přičemž je výsledné chování aplikace stejné\footnote{Překlad knihovny byl testován za použití překladačů \emph{GCC}, \emph{Clang} a \emph{MSVC}, více ke specifikaci testovacích systémů lze najít v~kapitole \ref{Chap:Results}.}. 

Pro implementaci entitního systému byly použity pouze standardní knihovny jazyka \emph{C++}, čímž jsou zmírněny potenciální komplikace při používání výsledné knihovny. Při vývoji bylo také použito \emph{šablonového metaprogramování} \cite{CppMetaprogramming}, které umožňuje vyšší úroveň práce s typy.

\section{Komponenty}

Komponenty lze definovat jako třídy (nebo struktury), pro která platí určitá omezení. Prvním z~nich je požadavek, aby komponenta obsahovala pouze data, která lze kopírovat jako čistou paměť (\emph{POD}), jelikož volání konstruktorů a destruktorů není zaručeno. Komponenta může obsahovat konstruktory, které inicializují data na jejich požadovanou hodnotu, ale vždy musí existovat výchozí konstruktor. Komponenty mohou také specifikovat, který nosič by měl být použit pro jejich uchovávání. Typ nosiče je definován v~zanořeném typu s~názvem \textbf{HolderT}.

Registrace komponent je prováděna pomocí statických šablon proměnných, kde pro každý typ komponent je vytvořena při překladu\footnote{Díky tomu, že jsou registry statické proměnné.} instance typu \textbf{ComponentRegister} (diagram na obr. \ref{Fig:DESCompDiag}). Tento registr obsahuje kromě informací o~komponentě také instanci jejího nosiče. Díky \emph{šablonovému metaprogramování} je možné přímé mapování komponenty na instanci jejího nosiče za překladu programu, což umožňuje překladači vyšší úroveň optimalizace.

Knihovna obsahuje několik typů základních nosičů komponent. Prvním z~nich je implementace využívající standardní mapu (\textbf{std::map}), která mapuje identifikátory entit přímo na instance jednotlivých komponent. Tento typ nosiče je výhodný pro komponenty, které nejsou příliš často používané. Dalším typem je nosič, který obsahuje souvislé pole komponent a mapu, která umožňuje mapování identifikátoru entity na index do pole komponent. Tento nosič je výhodný v~případech, kdy komponenty stále nejsou příliš časté, ale jsou zpracovávány v~blocích. Poslední typ nosiče je implementován jako čisté pole komponent, kde je mapování prováděno přímou indexací, pomocí identifikátoru entity. Výhodou je konstantní složitost přístupu k~jednotlivým komponentám, nevýhodou potom paměťová náročnost v~případě, kdy daný komponent neobsahuje každá entita. 

Uživatelům knihovny je umožněna implementace vlastních nosičů komponent, vytvořením třídy, která dědí ze základní třídy \textbf{BaseComponentHolder}. Jelikož informace zda entita obsahuje daný komponent je zpravována podsystémem entit, je velmi jednoduché implementovat např. nosič značek\footnote{Značka je komponent, který neobsahuje žádná data.}. 

\section{Správa entit}

Entity jsou definované pomocí identifikátorů, složených ze dvou částí -- index a generace. Index určuje číslo řádku v~tabulce entit a je také používán pro mapování komponent na entity. Generace určuje specifickou entitu, která \uv{obývá} daný řádek tabulky entit. Tento identifikátor je implementovaný jako třída \textbf{EntityId}, která, na rozdíl od návrhu, obsahuje pouze jedno číslo, rozdělené pomocí bitových operací do dvou částí (obr. \ref{Fig:IMPLIdent}). Ve výchozím nastavení knihovny je identifikátor reprezentován 32-bitovým číslem bez znaménka, indexová část zabírá 24 bitů a generace 8 bitů\footnote{Tato nastavení lze změnit v~hlavičkovém souboru.}. Validní identifikátor obsahuje indexové číslo, které není rovné nule. Speciálním případem identifikátoru je identifikátor dočasné entity, jehož generační číslo je rovno maximální hodnotě (255 pro výchozí nastavení).

\begin{figure}[H]
	\begin{center}
		\tmpframe{\includegraphics[scale=0.7]{BAC-IMPL1}}
	\end{center}
	\caption{Rozdělení identifikátoru entit na generaci a index.}
	\label{Fig:IMPLIdent}
\end{figure}

Informace o~entitách je uložena v~tabulce entit, která obsahuje -- aktuální generaci, přítomnost komponent, přítomnost entity ve skupinách, aktivitu a informaci o~tom, zda je daný řádek použitý. Až na generaci lze všechny informace reprezentovat jedním bitem, který je vždy ve stavu '1' (\emph{true}) nebo '0' (\emph{false}). Jelikož standardní množina bitů (\textbf{std::bitset}) nezaručuje uložení bitů v~souvislé paměti, vznikla za tímto účelem třída \textbf{InfoBitset}. Kromě souvislého uložení paměťových bloků, které obsahují jednotlivé bity, má \textbf{InfoBitset} další výhodu v~tom, že výše zmíněné paměťové bloky jsou uloženy ve třídě samotné a tudíž je možné její instance přesouvat pomocí operací s~pamětí (\emph{std::memcpy} atp.).

\begin{figure}[H]
	\begin{center}
		\tmpframe{\includegraphics[scale=0.7]{BAC-IMPL2}}
	\end{center}
	\caption{Implementace tabulky metadat pomocí množin bitů \textbf{InfoBitset}. Tabulka obsahuje následující informace -- komponenty, skupiny, aktivitu, použití řádku a generaci. Z~této množiny informací jsou všechny, až na generaci, reprezentovány pomocí množin bitů.}
	\label{Fig:IMPLMetadata}
\end{figure}

Existují dva způsoby, jak organizovat jednotlivé bitové množiny -- horizontálně a vertikálně, ilustraci lze vidět na obr. \ref{Fig:IMPLMetadata}. Horizontální tabulka metadat obsahuje jednotlivé sloupce v~bitech stejné množiny bitů, na rozdíl od vertikální tabulky metadat, kdy pro každý typ metadat (např. každý typ komponent) existuje oddělený sloupec množin bitů. 

Mezi výhody horizontálního ukládání metadat patří jednodušší implementace a rychlejší filtrování\footnote{Filtrování je v~tomto případě porovnání dvou čísel.}. Velkou nevýhodou je však problematický paralelní přístup k~jednotlivým bitům, jelikož není možné zaručit atomické bitové operace -- operace nad jedním bitem ovlivňují celý blok bitové paměti. 

Vertikální metadata naopak umožňují paralelní přístup k~odděleným sloupcům, díky čemuž je tato možnost použita ve finální implementaci této knihovny. Středem tabulky je třída \textbf{MetadataGroup}, která umožňuje udržovat skupinu sloupců metadat. Sloupce tabulky metadat jsou rozděleny do tří skupin -- komponenty, skupiny a ostatní. Skupina ostatních metadat obsahuje aktivitu entit a využitelnost řádku.

Operace vytvoření entity je realizována přidáním řádku do tabulky entit, nebo, pokud je dostatek volný identifikátorů, použití již dříve vytvořeného řádku. Při operaci mazáni entit, je důležitou součástí inkrementace generačního čísla, které identifikuje jednotlivé entity, které existovaly na stejném řádku. Při recyklaci řádku má nově vytvořená entita stejný index, ale rozdílné generační číslo. 

Jelikož by při opakovaném vytváření a mazání stejných entit mohlo dojít k~rychlému vyčerpání generačních čísel a jejich přetečení\footnote{Není samo o~sobě chyba, ale je vhodné se vyhnout příliš vysoké frekvenci opakováni generačních čísel.}, je seznam volných řádků implementován jako oboustranná fronta -- smazané indexy jsou přidány na konec fronty, odběr je prováděn začátku fronty. Tímto je dosažena lepší distribuce generačních čísel a nižší frekvence přetečení jednotlivých čítačů.

\section{Systémy a skupiny}
\label{Chap:ImplSystem}

\emph{Systémy} jsou vytvářeny uživateli knihovny, děděním základní třídy \textbf{System}. Následně je nutné \emph{systém} přidat použitím metody \textbf{addSystem}, která také zaručí jeho inicializaci a~přiřazení odpovídající \emph{skupiny}. Doba života instance daného \emph{systému} je spravována entitním systémem, čímž jsou zamezeny problémy při nevalidním smazání používaného \emph{systému} ze strany uživatele knihovny.

Definice požadovaných entit je přístupná uživateli skrz typové proměnné \textbf{Require} a \textbf{Reject}. Jejich výchozí hodnota je prázdná, což znamená, že \emph{systém} přijímá všechny (aktivní) entity. Požadovanou hodnotu lze specifikovat skrz pomocné seznamy typů následujícím způsobem: 

\begin{lstlisting}[language=C++]
	using Require = ent::Require<PositionC, MovementC>;
	using Reject = ent::Reject<>;
\end{lstlisting}

\noindent kde \textbf{PositionC} a \textbf{MovementC} jsou požadované komponenty. \emph{Systémy} dále obsahují pomocné metody, které umožňují přístup k~jednotlivým typům entitních seznamů -- přidané (\textbf{foreachAdded}), odebrané (\textbf{foreachRemoved}) a celý seznam (\textbf{foreach}).

\begin{figure}[H]
	\begin{center}
		\tmpframe{\includegraphics[scale=0.7]{BAC-IMPL3}}
	\end{center}
	\caption{Aktualizace seznamů \emph{skupin}.}
	\label{Fig:IMPLMerge}
\end{figure}

Středem \emph{skupin} je třída \textbf{EntityGroup}, jejíž úkolem je udržování seznamů přidaných, odebraných a vyhovujících entit. Jelikož všechny operace musí procházet skrz rozhraní knihovny (\textbf{Universe}), je možné tvořit seznam entit, které se změnily. Během fáze \emph{obnovení} je seznam použit pro generování nových seznamů přidaných a odebraných entit pro každou \emph{skupinu}. Operace synchronizace \emph{skupin} je dokončena tří-směrným sloučením seznamů přidaných, odebraných a aktuálních entit. Ilustraci tohoto postupu lze vidět na obr. \ref{Fig:IMPLMerge}.

\section{Podpora paralelizmu}

Knihovna podporuje tři typy paralelního přístupu -- systémy, entity a \emph{množiny změn}. Pro paralelní zpracování několika systémů, které nepřistupují ke stejným komponentám, nebylo třeba příliš práce, díky způsobu, kterým je knihovna navržena a využití \emph{vertikální} tabulky metadat. Paralelizací na úrovni entit je myšleno rozdělení \emph{skupiny} entit jednoho \emph{systému} mezi několik vláken, které dané entity zpracovávají odděleně\footnote{Bez použití operací, které ovlivňují globální kontext -- odebírání komponent apod.}. Jelikož je tabulka metadat implementována pomocí \emph{bitových množin}, které nezaručují bezpečnost operací práce s~bity, při přístupu z~několika vláken zároveň, bylo třeba implementovat speciální typ \emph{iterátoru} -- třída \textbf{EntityListParallel}. Úkolem tohoto \emph{iterátoru} je rozdělení seznamu entit do daného množství (podle počtu vláken) podmnožin. Normální iterace nad všemi vyhovujícími entitami vypadá následovně:

\begin{lstlisting}[language=C++]
	for (auto &e : foreach())
	{
	    PositionC *p{e.get<PositionC>()};
	    MovementC *m{e.get<MovementC>()};
	    p->x += m->dX;
	    p->y += m->dY;
	}
\end{lstlisting}

\noindent Paralelní iterace pro 4 vlákna nad množinou, které patří třetímu vláknu potom může vypadat takto:

\begin{lstlisting}[language=C++]
	auto parForeach = foreachP(4);
	for (auto &e :parForeach.forThread(2))
	{ /* ... */ }
\end{lstlisting}

Při implementaci \emph{množin změn} vyvstaly problémy s~typovým systémem jazyka \emph{C++}. Akce nad komponenty -- přidání, odebrání a změny hodnot -- vyžadovaly oddělené seznamy, které je možné uniformě aplikovat v~\emph{obnovovací fázi}. Tento problém byl vyřešen využitím \emph{šablonového metaprogramování}, kde ve \emph{fázi registrace} jsou registrovány také instance třídy \textbf{ComponentExtractor}. Tato třída následně operuje jako most mezi třídou \textbf{ActionCache} a specifickými seznamy komponent.

Operace, jejichž provedení je odloženo na později, mají postfix \uv{\textbf{D}} (\uv{deferred}) a operace, které pracují s~\uv{dočasnými} entitami jsou zakončeny \uv{\textbf{T}} (\uv{temporary}).

\section{Obnovení konzistence}

Cílem \emph{obnovovací fáze} (\textbf{refresh}) je uvedení entitního systému konzistentního stavu a dokončení operací, které nemohly být provedeny při jeho aktivním používání. Základní postup obnovy lze vidět na alg. \ref{Alg:Refresh}. Zajímavou částí je obnova \emph{skupin}, která využívá seznamu změněných entit, díky kterému není třeba procházet všechny entity, ale pouze ty, které byly změněny od poslední obnovy konzistence. Tento seznam je tvořen při normálním používání entitního systému a při obnovovací fázi \emph{správy akcí}, kdy jsou aplikovány \emph{množiny změn}. Seznamy jsou implementovány jako seřazené pole identifikátorů entit, kdy každé vlákno, které pracuje s~entitním systémem má tento seznam vlastní. Před předáním seznamu obnovovací funkci \emph{správy skupin} je nutné provést spojení seznamů jednotlivých vláken.

\begin{algorithm}
	\caption{Postup obnovení}
	\label{Alg:Refresh}
	
	\begin{algorithmic}[1]
		\algblock[EMBlock]{EMBlockStart}{EMBlockEnd}
		\algtext{EMBlockStart}{\textbf{Obnova správy entit}}
		\algtext*{EMBlockEnd}
		\algblock[ACBlock]{ACBlockStart}{ACBlockEnd}
		\algtext{ACBlockStart}{\textbf{Obnova správy akcí}}
		\algtext*{ACBlockEnd}
		\algblock[CMBlock]{CMBlockStart}{CMBlockEnd}
		\algtext{CMBlockStart}{\textbf{Obnova správy komponent}}
		\algtext*{CMBlockEnd}
		\algblock[GMBlock]{GMBlockStart}{GMBlockEnd}
		\algtext{GMBlockStart}{\textbf{Obnova správy skupin}}
		\algtext*{GMBlockEnd}
		
		\Function{refresh}{}
			\EMBlockStart
				\State Finalizace přidání skupin
			\EMBlockEnd
			\ACBlockStart
				\State Smazat označené entity
				\State Přidat nové entity
				\State Přidat/odebrat komponenty
				\State Změna aktivity entit
			\ACBlockEnd
			\CMBlockStart
				\State Obnova jednotlivých nosičů komponent
			\CMBlockEnd
			\GMBlockStart
				\State Obnova skupin -- vyprázdnění seznamů přidaných a odebraných entit
				\State Odebrání nepoužívaných skupin
				\State Kontrola seznamu změněných entit a synchronizace skupin
				\State Dokončení operace synchronizace skupin
			\GMBlockEnd
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\pagebreak
\section{Možnosti rozšíření}
\label{Chap:ExtensionOptions}

Obsah kapitoly \uv{implementace} obsahuje stav knihovny tak, jak byla odevzdána s~touto technickou zprávou. Přestože již umožňuje všechny funkce popsané v~kapitole \uv{návrh}, nelze ji považovat za plně dokončenou z~důvodu přílišného rozsahu projektu. Aktuální stav implementace lze nalézt v~\emph{GIT repozitáři} \cite{EntropyGit}, pod názvem \uv{Entropy}. Následují možné směry, kterými bude její vývoj dále postupovat: 

\begin{itemize}
	\item \textbf{Vazba na vestavěné skriptovací jazyky} -- Umožnit přístup k~entitnímu systému skrz některý z~často používaných vestavěných skriptovacích jazyků -- např. \emph{LUA}. 
	\item \textbf{Datově definované entity} -- Podpora definice entit a komponent v~externích souborech (např. formátu \emph{JSON}) a možnosti serializace komponent. Dále také možnost tvorby entit po blocích a specifikace identifikátoru vytvořené entity.
	\item \textbf{Dynamické komponenty} -- Díky způsobu implementace tabulky metadat je teoreticky možné přidávat nové typy komponent i za běhu aplikace, mimo inicializační fázi. Spojení této vlastnosti s~vazbou na skriptovací jazyk by umožnilo případným herním návrhářům větší volnost, bez nutnosti opakovaného překládání zdrojového kódu v~jazyce \emph{C++}.
	%\item \textbf{Tvorba entit} -- Možnosti tvorby entit po blocích a specifikace identifikátoru vytvořené entity.
	\item \textbf{Volitelné použití skupin} -- Pro \emph{skupiny}, které obsahují téměř všechny entity je výhodnější iterovat nad všemi entitami. Dalším rozšířením skupin je umožnění specifikace požadované úrovně aktivity entit.
	\item \textbf{Bezpečnost entit} -- Rozdělit entity na bezpečné a nebezpečné, kdy pro nebezpečné entity jsou provedeny kontroly při každém přístupu k~entitnímu systému.
	\item \textbf{Paralelizace obnovovací fáze} -- Jednotlivé akce, které jsou prováděny součástí obnovovací fáze lze paralelizovat, ale tato vlastnost prozatím není implementována.
\end{itemize}

%\chapter{Použití knihovny}
%\label{Chap:Demo}

%\section{Demo hra}
%\todo{Popis principů hry}
%\blind[1]

%\section{Návrh}
%\todo{Komponentní návrh}
%\blind[3]

%ukazka kodu

%\section{Zhodnocení}
%\todo{Výkon, návrh, jednoduchost}
%\blind[3]

\chapter{Vyhodnocení}
\label{Chap:Results}

%Obsahem této kapitoly je vyhodnocení výsledné implementace z~pohledy výkonosti a použitelnosti. První část představuje hardwarové a softwarové konfigurace systémů, na kterých bylo prováděno testování. Následuje popis použitých nástrojů, použitých ve vyhodnocení a jejich výsledků. Poslední část obsahuje porovnání implementace představené v~této práci s~podobnými volně dostupnými knihovnami.

Tato kapitola obsahuje vyhodnocení výsledné implementace knihovny \uv{Entropy} a její porovnání vůči ostatním, volně dostupným knihovnám. Mezi testované scénáře patří operace s~entitami, výpočetní \emph{systém}, přesun entit mezi \emph{skupinami}, nosiče komponent a paralelizmus.

\section{Testované sestavy}

Součástí vývoje knihovny bylo prováděno její testování na konfiguracích uvedených v~tabulce \ref{Tab:HW}. Překlad byl prováděn za použití nejvyšší úrovně optimalizace (\verb|-O3|, \verb|\O2|), použité překladače a jejich verze lze najít v~tabulce \ref{Tab:Compiler}. 

\begin{table}[H]
	\begin{center}
		\begin{tabular}{| c | c | c |}
			\hline
			\textbf{ID} & \textbf{CPU} & \textbf{Operační paměť} \\
			\hline
			1 & Intel Core i7-4710HQ CPU @ 2.50\,GHz -- 4 cores & 8\,GB DDR3 @ 1600\,MHz \\
			\hline
			2 & Intel Core i5-4670K CPU @ 3.40\,GHz -- 4 cores & 24\,GB DDR3 @ 1600\,MHz \\
			\hline
		\end{tabular}\\[1em]
		\begin{tabular}{| c | c |}
			\hline
			\textbf{ID} & \textbf{Operační systém} \\
			\hline
			1 & Linux x86\_64, Fedora 25 -- kernel 4.9.3-200.fc25.x86\_64 \\
			\hline
			2 & Windows x86\_64, Windows 10 Pro -- version 1607, OS build 14393.447 \\
			\hline
		\end{tabular}
		\caption{Tabulka s~testovanými hardwarovými konfiguracemi.}
		\label{Tab:HW}
	\end{center}
\end{table}

\begin{table}[H]
	\begin{center}
		\begin{tabular}{| c | c | c |}
			\hline
			\textbf{ID} & \textbf{Překladač} & \textbf{Verze} \\
			\hline
			1 & GCC & 6.3.1 20161221 (Red Hat 6.3.1-1) \\
			\hline
			1 & Clang & 3.9.1 \\
			\hline
			2 & Microsoft C/C++ Optimizing Compiler & 19.10.24728 \\
			\hline
		\end{tabular}\\[1em]
		\caption{Tabulka s~testovanými překladači jazyka \emph{C++}. \textbf{ID} obsahuje identifikátor z~tab. \ref{Tab:HW}.}
		\label{Tab:Compiler}
	\end{center}
\end{table}

\section{Použité nástroje}

Důležitou součástí vývoje bylo testování knihovny pomocí metody \emph{unit testing}. Pro tento účel je využito jednoduché knihovny v~jazyce \emph{C++}\footnote{Tato knihovna byla vytvořena autorem této práce a není jiným způsobem zveřejněna.}, která umožňuje psát testy přímo ve zdrojovém kódu. Kromě testování bylo také prováděno profilování různých částí knihovny, kvůli možným optimalizacím, k~čemuž bylo opět využita výše zmíněná knihovna. 

Kromě nástrojů zabudovaných přímo do zdrojového kódu byly také použity externí aplikace : 
\begin{itemize}
	\item \textbf{GDB -- GNU Debugger}
	\item \textbf{Valgrind} -- Primárně moduly -- \emph{callgrind}, \emph{cachegrind}, \emph{helgrind} a \emph{massif}.
	\item \textbf{ms\_print}
	\item \textbf{KCachegrind}
\end{itemize}

\noindent Pro tvorbu této práce byly také využity následující aplikace:
\begin{itemize}
	\item \textbf{draw.io} -- Tvorba diagramů, schémat a ilustrací.
	\item \textbf{R} -- Grafy, které jsou použity v této kapitole.
\end{itemize}

\section{Výkonnostní testy}

Tato část obsahuje výsledky výkonnostních testů spuštěných ná výše popsané implementaci entitního systému. Hlavním cílem je předvést co aktuální implementace knihovny zvládá a~jak ji lze porovnat s~jinými implementacemi entitních systémů založených na \emph{ECS}. Kromě výkonosti implementace jsou zde také ukázány vlastnosti, které pramení z~návrhu systému, jako např. časová složitost jednotlivých operací.

Kromě implementace, kterou navrhuje tato práce (nazvaná \textbf{Entropy}), jsou zde také testovány jiné \emph{open-source} knihovny, mezi které patří:
\begin{itemize}
	\item \textbf{Anax} \cite{Anax}
	\item \textbf{ArtemisCpp} \cite{ArtemisCpp} -- Implementace knihovny \textbf{Artemis} \cite{ArtemisJava} v~jazyce \emph{C++}.
	\item \textbf{EntityX} \cite{EntityX} -- Obsahuje i pokročilejší funkce, např. systém událostí. Z~těchto knihoven je \textbf{EntityX} nejvíce dokončená a optimalizovaná.
\end{itemize}

Všechny testy a výsledky, které jsou zobrazeny v~této sekci byly provedeny na hardwarové konfiguraci č. 1 z tabulky \ref{Tab:HW}. Zdrojové kódy, knihoven i testovaných bloků, byly přeloženy pomocí překladačem \emph{GCC} (tabulka \ref{Tab:Compiler}), s~parametry \texttt{-std=c++1z -O3}. Jednotlivé testovací scénáře byly následně spouštěny po uzamčení procesoru do módu nejvyššího výkonu, spolu s~příkazem \texttt{nice -n -20}, který aplikaci spustí s vyšší prioritou. Výsledná data byla zpracována aplikací \emph{R} \cite{RHome}, jejíž výstupem jsou prezentované grafy.

Pojem \emph{výpočet} v následujících sekcích vždy odkazuje na stejnou operaci, která má za úkol simulovat provedení výpočtu nad komponentami. V případě následujících scénářů je \emph{výpočtem} operace nad čísly s plovoucí řádovou čárkou a aplikace matematických funkcí \emph{sinus} a \emph{cosinus}.

Ve všech případech, až na testování jednotlivých nosičů, jsou v testech používány dva typy komponent. Obě komponenty obsahují dva atributy typu \texttt{float} a v případě \textbf{Entropy} používají nosič typu pole. 

\subsection{Tvorba entit}

\begin{figure}[H]
	\begin{center}
		\tmpframe{\includegraphics[scale=0.4]{entityCreationGraph}}
	\end{center}
	\caption{Graf výsledků pro přidání určitého počtu entit.}
	\label{Fig:EVALEntity}
\end{figure}

Obsahem prvního scénáře je tvorba určitého počtu entit, včetně dvou menších (8B) komponent. Cílem tohoto testu je zjistit, jakou časovou složitost má operace v závislosti na přidaném počtu entit. Výsledný graf lze najít na obr. \ref{Fig:EVALEntity}, kde horizontální osa obsahuje počet vytvářených entit a vertikální čas vytvoření jedné z nich. 

Z~grafu lze určit, že časová složitost tvorby entit pro knihovnu \textbf{Entropy}, v závislosti na jejich celkovém počtu, je \emph{konstantní}. Toto umožňuje entitnímu systému obsahovat vysoké množství entit, bez omezení rychlosti vykonávání následujících akcí. Rozdíl mezi knihovnou \textbf{Entropy} a ostatními knihovnami lze vysvětlit tím, že akce tvorby entity a přidání komponent musí identifikátor entity přidat do seznamu změněných entit.

\subsection{Výpočetní systém}

\begin{figure}[H]
	\begin{center}
		\tmpframe{\includegraphics[width=0.49\linewidth]{movementSystemGraph}}
	\end{center}
	\caption{Jednoduchá iterace pohybového \emph{systému}.}
	\label{Fig:EVALMovSys}
\end{figure}

Předmětem druhého scénáře je použití entitního systému k provedení \emph{výpočtu}. V první fázi testu je vytvořen určitý počet entit (V tomto případě $10\,000$.), následně je náhodně vybráno procento z nich, kterým jsou přidány 2 komponenty. Výsledný graf lze najít na obr. \ref{Fig:EVALMovSys}, horizontální osa obsahuje procentuální zastoupení entit, nad kterými bylo iterováno a~vertikální průměrný čas jedné iterace. Graf, kromě jednotlivých knihoven, obsahuje také využití paralelizace knihovny \textbf{Entropy}. V tomto případě byl celkový počet iterovaných entit rozdělen mezi dvě, nebo čtyři výpočetní vlákna. 

V grafu lze vidět lineární nárůst průměrné doby na jednu iteraci, který odpovídá zvyšujícímu se počtu iterovaných entit. Časový průběh pro knihovnu \textbf{ArtemisCpp}, je v tomto případě pravděpodobně způsoben implementací filtrování entit. Zajímavé průběhy mají také paralelní verze knihovny \textbf{Entropy}, kde se ze začátku ukazuje nevýhoda rozdělení malého počtu entit mezi více vláken. 

\subsection{Změny obsažených komponent}

\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{0.49\textwidth}
		\tmpframe{\includegraphics[width=\textwidth]{advancedMovementSystemLowGraph}}
		\caption{Nižší procenta změn.}\label{Fig:EVALAdvMovSysLow}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\tmpframe{\includegraphics[width=\textwidth]{advancedMovementSystemHighGraph}}
		\caption{Vyšší procenta změn.}\label{Fig:EVALAdvMovSysHigh}
	\end{subfigure}
	\caption{Iterace nad entitami s~daným procentem změn v obsažených komponentách.}
\end{figure}

Následující testovací scénář porovnává, jakým způsobem se jednotlivé implementace chovají, v~případě, kdy entity mění svou množinu přítomných komponent. V první fázi je opět vytvořen stejný počet entit -- $10\,000$. Na rozdíl od předchozího případu jsou oba komponenty přidány všem entitám. Kromě základního \emph{systému}, který provádí \emph{výpočet}, je zde také \emph{systém}, jehož úkolem je náhodně přidávat a odebírat komponenty. Tímto je simulována změna entit, čímž je vynucena aktualizace \emph{entitních skupin}. Výsledný graf je rozdělený na nižší procenta změn (obr. \ref{Fig:EVALAdvMovSysLow}) a vyšší procenta změn (obr. \ref{Fig:EVALAdvMovSysHigh}). Horizontální osa obsahuje v kolika procentech případů je množina komponent, které entita vlastní, změněna. Vertikální osa opět obsahuje průměrný čas na jednu iteraci obou systémů a následnou \emph{obnovovací fázi}.

Z grafu lze vidět, že je knihovna \textbf{Entropy} dokáže udržet stejnou úroveň výkonu i přestože musí obnovovat obsah \emph{entitních skupin}. Lineární charakter výsledné křivky lze zdůvodnit tím, že počet \emph{výpočtů} byl -- v případě vyššího počtu změn -- snížen. Při využití paralelizace lze vidět předpokládaný nárůst výkonu, který je přibližně lineární v závislosti na počet vláken.

\subsection{Nosiče komponent}

\begin{figure}[H]
	\centering
	\begin{subfigure}[b]{\textwidth}
		\tmpframe{\includegraphics[width=0.32\linewidth]{holdersS}}
		\tmpframe{\includegraphics[width=0.32\linewidth]{holdersM}} 
		\tmpframe{\includegraphics[width=0.32\linewidth]{holdersL}}
		\caption{Sekvenční přístup, velikosti 16\,B, 64\,B a 128\,B.}\label{Fig:EVALHoldersSeq}
	\end{subfigure}
	\begin{subfigure}[b]{\textwidth}
		\tmpframe{\includegraphics[width=0.32\linewidth]{holdersRS}}
		\tmpframe{\includegraphics[width=0.32\linewidth]{holdersRM}} 
		\tmpframe{\includegraphics[width=0.32\linewidth]{holdersRL}}
		\caption{Náhodný přístup, velikosti 16\,B, 64\,B a 128\,B.}\label{Fig:EVALHoldersRand}
	\end{subfigure}
	\caption{Porovnání nosičů komponent pro komponenty různých velikostí.}
\end{figure}

Dalším testovaným aspektem výsledné knihovny je porovnání různých typů \emph{nosičů komponent}. Po vytvoření stejného množství entit, jako v předchozích případech, začíná měřený úsek, kdy je každé entitě přidán daný typ komponenty. Každý nosič je testován se třemi typy komponent -- malé (16 bytů), střední (64 bytů) a velké (128 bytů). Tyto velikosti byly zvoleny, kvůli rozměrům řádku vyrovnávací paměti, která je v případě testované soustavy 64\,B. Následuje druhý měřený úsek, ve kterém je přistupováno k entitám a jejich komponentám. Poměr operací přidání k operacím přístupu je 1:20, čímž je simulována předpokládaná zátěž entitního systému. K jednotlivým komponentám je přistupováno sekvenčně (obr. \ref{Fig:EVALHoldersSeq}) a náhodně (obr. \ref{Fig:EVALHoldersSeq}).

První vlastností, kterou lze z grafů vypozorovat, je na první pohled jednoznačná výhody nosiče typu \textbf{List}. Tento výsledek je dosažen implementací tohoto nosiče -- jednoduché pole, které je indexováno identifikátorem entit. Za tuto výhodu je zaplaceno vyšší paměťovou náročností, v případech, kdy není pole zaplněno. Zajímavou vlastnosti, kterou lze vidět na průbězích nosiče \textbf{List}, jsou \uv{zuby}, které vznikají kvůli alokaci většího bloku paměti.

Pro komponenty nejmenší velikosti jsou nosiče \textbf{Map} a \textbf{MapList} na stejné úrovni. Důvodem je pravděpodobně lepší datová lokalita nosiče \textbf{MapList}, díky které je do vyrovnávací paměti načteno vyšší množství instancí čtených komponent. Tato výhoda je, v případě větších komponent, přebita režií udržování \emph{mapy} i \emph{pole}. 

\subsection{Paralelní zpracování}

\begin{figure}[H]
		\centering
	\begin{subfigure}[b]{0.49\textwidth}
		\tmpframe{\includegraphics[width=\textwidth]{entityParallelGraph}}
		\caption{Entitní paralelizmus.}\label{Fig:EVALPar}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\tmpframe{\includegraphics[width=\textwidth]{entityChangesetGraph}}
		\caption{Množiny změn.}\label{Fig:EVALChangeset}
	\end{subfigure}
	\caption{Relativní urychlení testovaného \emph{výpočtu} při použití daného počtu vláken.}
\end{figure}

Cílem závěrečného scénáře je otestovat, jak výhodné je použití několika vláken při přístupu k~entitnímu systému. Testovaný systém opět zpracovává entity dříve použitým \emph{výpočtem}. V~první části je vytvořeno $10\,000$ entit, kde každé z~nich jsou přiřazeny dvě komponenty. V~prvním případě (obr. \ref{Fig:EVALPar}) je množina entit rozdělena mezi jednotlivá vlákna. Ve druhém případě (obr. \ref{Fig:EVALChangeset}) je místo přímého zápisu výsledných hodnot použito \emph{množin změn}, s odloženým vykonáním. Součástí měřeného úseku je také obnova entitního systému. Horizontální osy obsahují počet vláken, který byl při zpravování použit. Vertikální obsahuje informaci o tom, kolikrát rychleji byly jednotlivé iterace dokončeny. Tato hodnota je relativní, vůči základnímu případu, kdy je použito pouze jedno vlákno.

Grafy ukazují téměř lineární škálování s počtem vláken, až do počtu fyzických jader testovaného systému (4 jádra). Následně lze na grafech vidět propad, při přechodu ze čtyř na pět vláken, který lze zdůvodnit využitím maximálního počtu fyzických jader. Dalším možným vysvětlením tohoto propadu je začátek použití technologie. Využití maximálního možného počtu vláken lze na grafu vidět ve formě maxima, při použití 8 vláken. Následně výkon opět klesá, kvůli režii správy jednotlivých vláken.

Graf použití \emph{množin změn} (obr. \ref{Fig:EVALChangeset}) ukazuje mírnější vzrůst relativní úrovně výkonu, která je způsobena odloženým zpracováním požadovaných akcí. Tuto situaci lze vylepšit dokončením implementace paralelní \emph{obnovovací fáze}.

Škálování s počtem jader velmi závisí na složitosti úlohy, kterou jádra musí zpracovávat. Při jednoduchých operacích je režie na tvorbu vláken a údržba koherence vyrovnávacích pamětí příliš časově náročná na to, aby se paralelizace vyplatila.

\chapter{Závěr}

Cílem této bakalářské práce byl návrh a následná implementace entitního systému, který umožňuje vývoj aplikací za použití \emph{Entity-Component-System} paradigmatu. Důležitou částí bylo studium aktuálních problémů při vývoji her a architektury moderních počítačů, díky kterým \emph{ECS} paradigma vzniklo. 

Při návrhu byly kromě základních vlastností \emph{ECS} také zohledněny požadavky na paralelní přístup a jednoduchou integraci do existujících projektů. Před vytvořením výsledného návrhu vzniklo několik prototypů, jejichž cílem bylo určit vhodnost návrhu a~jeho proveditelnost v~jazyce \emph{C++}. 

%Další důležitou částí této práce bylo studium aktuálně existujících implementací a jejich vlastností, které byly ve zkratce popsány i v~této zprávě. Následně byly zmíněné znalosti použity při návrhu vlastního entitního systému. Kromě základních vlastností \emph{ECS}, patřilo mezi priority také paralelní přístup, který je u~jiných knihoven v~mnoha případech nemožný. Před vytvořením výsledného návrhu, tak, jak je popsán v~práci samotné, vzniklo několik prototypů, jejichž cílem bylo určit vhodnost návrhu a jeho proveditelnost v~jazyce \emph{C++}. 

Implementace byla provedena v~programovacím jazyce \emph{C++}. Při implementaci byly použity pokročilé vlastnosti jazyka, jako jsou \emph{šablony} a \emph{šablonové metaprogramování}. Dále bylo využito standardní knihovny a menších knihoven, dříve vytvořených autorem této práce. Implementováno bylo samotné jádro entitního systému, které umožňuje práci s \emph{entitami}, \emph{komponentami} a \emph{systémy}. Kromě těchto základních vlastností umožňuje implementace také všechny tři typy paralelizace -- \emph{entitní}, \emph{systémová} a pomocí \emph{množin změn}. 

%Implementace byla provedena v přenositelným způsobem, který umožňuje využití knihovny na více platformách.

%Závěrečnou částí implementace je její testování na operačních systémech \emph{Windows} a \emph{Linux}.

Výsledkem práce je multiplatformní knihovna \textbf{Entropy}, která umožňuje návrh aplikací za použití \emph{Entity-Component-System} paradigmatu. Hlavním úspěchem je možnost paralelního přístupu, který jiné knihovny nepodporují. Při porovnání výsledné implementace se knihovna \textbf{Entropy} výkonnostně řadí mezi ty rychlejší, přičemž je možné ji dále optimalizovat. Mezi možné optimalizace patří -- paralelizace \emph{obnovovací} fáze, rozdělení seznamů změněných entit podle \emph{skupin} nebo kompletní konverze filtrování na použití \emph{bitových množin}.

Autor práce bude dále pokračovat ve vývoji výsledné knihovny, jejíž aktuální verze je k~dispozici v~repositáři \emph{Git} \cite{EntropyGit}. Mezi plánovaná rozšíření patří vazba entitního systému na vestavěný skriptovací jazyk. Tímto bude umožněno herním návrhářům měnit chováni hry, bez nutnosti opětovného překládání celé hry. Další vlastností, která využívá právě vazby na skriptovací jazyk, je možnost přidávat nové typy komponent za běhu aplikace, nebo definovat entity v~externích souborech (např. formátu \emph{JSON}). 

%\begin{figure}
%	\tmpframe{\includegraphics[width=\linewidth]{TODO-image}}
%	\caption{Obrazek \todo{Obrazek}}
%\end{figure}

%=========================================================================
